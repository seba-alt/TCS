---
phase: 10-search-intelligence-layer
plan: "02"
type: execute
wave: 2
depends_on:
  - "10-01"
files_modified:
  - app/routers/chat.py
  - .env.example
autonomous: false
requirements:
  - SEARCH-01
  - SEARCH-02
  - SEARCH-03
  - SEARCH-04
  - SEARCH-05
  - SEARCH-06

must_haves:
  truths:
    - "The chat SSE result event includes an intelligence field with hyde_triggered, hyde_bio, and feedback_applied"
    - "POST /api/chat responds normally with or without the env var flags set"
    - "A HyDE Gemini call that takes longer than 5 seconds is cancelled and the request returns original results without hanging"
    - "Both QUERY_EXPANSION_ENABLED and FEEDBACK_LEARNING_ENABLED are documented in .env.example"
  artifacts:
    - path: "app/routers/chat.py"
      provides: "chat endpoint wired to search_intelligence wrapper"
      contains: "retrieve_with_intelligence"
    - path: ".env.example"
      provides: "env var documentation for both intelligence flags"
      contains: "QUERY_EXPANSION_ENABLED"
  key_links:
    - from: "app/routers/chat.py"
      to: "app/services/search_intelligence.py"
      via: "import retrieve_with_intelligence replacing retrieve"
      pattern: "from app\\.services\\.search_intelligence import retrieve_with_intelligence"
    - from: "app/routers/chat.py"
      to: "SSE result event"
      via: "intelligence dict added to _sse() call"
      pattern: "\"intelligence\""
---

<objective>
Wire app/routers/chat.py to use retrieve_with_intelligence() instead of retrieve(), add the intelligence metadata field to the SSE result event, and document the two new env vars in .env.example. Includes a human verification checkpoint to confirm the live endpoint returns the intelligence field.

Purpose: Activates the search intelligence layer in the request path. Both features default off so production is unaffected until Railway env vars are set.

Output: Modified chat.py + updated .env.example + human verification that the SSE result event includes intelligence metadata.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-search-intelligence-layer/10-CONTEXT.md
@.planning/phases/10-search-intelligence-layer/10-RESEARCH.md
@app/routers/chat.py
@.planning/phases/10-search-intelligence-layer/10-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire chat.py to search_intelligence and add SSE intelligence metadata</name>
  <files>app/routers/chat.py</files>
  <action>
Modify app/routers/chat.py to replace the direct retrieve() call with retrieve_with_intelligence() and add the intelligence field to the SSE result event.

**Step 1 — Update imports at top of file:**
Remove: `from app.services.retriever import retrieve`
Add: `from app.services.search_intelligence import retrieve_with_intelligence`

**Step 2 — Replace the retrieve executor call in _stream_chat:**

Current code (lines ~74-81):
```python
candidates = await loop.run_in_executor(
    None,
    lambda: retrieve(
        query=body.query,
        faiss_index=request.app.state.faiss_index,
        metadata=request.app.state.metadata,
    ),
)
```

Replace with:
```python
candidates, intelligence = await asyncio.wait_for(
    loop.run_in_executor(
        None,
        lambda: retrieve_with_intelligence(
            query=body.query,
            faiss_index=request.app.state.faiss_index,
            metadata=request.app.state.metadata,
            db=db,
        ),
    ),
    timeout=12.0,  # 5s HyDE LLM + 2s embed + safety margin; overall request must not hang
)
```

NOTE: asyncio.wait_for wraps the entire run_in_executor future. If HyDE times out internally (the 5s HYDE_TIMEOUT_SECONDS guard in search_intelligence.py handles that silently), the 12s outer timeout is a belt-and-suspenders safety net for Railway's 30s request timeout. If asyncio.TimeoutError fires at this level, it is caught by the existing `except Exception as exc` block which yields the error SSE event — no additional handling needed.

**Step 3 — Add intelligence to the SSE result event:**

Current code (lines ~124-130):
```python
yield _sse({
    "event": "result",
    "type": llm_response.type,
    "narrative": llm_response.narrative,
    "experts": experts_payload,
    "conversation_id": conversation.id,
})
```

Replace with:
```python
yield _sse({
    "event": "result",
    "type": llm_response.type,
    "narrative": llm_response.narrative,
    "experts": experts_payload,
    "conversation_id": conversation.id,
    "intelligence": intelligence,  # Admin Test Lab: hyde_triggered, hyde_bio, feedback_applied
})
```

**Step 4 — Update the log line after retrieval:**

Current: `log.info("chat.retrieved", candidate_count=len(candidates))`

Update to also log intelligence state:
```python
log.info(
    "chat.retrieved",
    candidate_count=len(candidates),
    hyde_triggered=intelligence.get("hyde_triggered", False),
    feedback_applied=intelligence.get("feedback_applied", False),
)
```

**Do NOT change:** The generate_response() call, the Conversation DB logging, the experts_payload building, the existing error/done SSE events, the StreamingResponse headers, or the Pydantic models. This is a surgical replacement of one function call and one SSE event augmentation.
  </action>
  <verify>
From /Users/sebastianhamers/Documents/TCS:
```
python -c "from app.routers.chat import router; print('Import OK')"
```
Expected: `Import OK`

Also verify the intelligence field is present:
```
grep -n "intelligence" app/routers/chat.py
```
Expected: lines showing `intelligence` in both the run_in_executor call result and the _sse dict.

Verify retrieve is no longer imported directly:
```
grep "from app.services.retriever import" app/routers/chat.py
```
Expected: no output (the import has been replaced).
  </verify>
  <done>
chat.py imports retrieve_with_intelligence (not retrieve). The run_in_executor call unpacks (candidates, intelligence). The SSE result event dict includes "intelligence": intelligence. The module imports cleanly with no errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Document new env vars in .env.example</name>
  <files>.env.example</files>
  <action>
Read the current .env.example and add two new env var entries in a new "Search Intelligence" section near the bottom (before any final comments).

Add:
```
# ── Search Intelligence ───────────────────────────────────────────────────────
# HyDE query expansion: generate a hypothetical expert bio for weak queries
# and blend it with the original embedding before FAISS search.
# Enable only after verifying retrieval quality on the enriched index.
QUERY_EXPANSION_ENABLED=false

# Feedback-weighted re-ranking: boost experts with 10+ positive feedback
# interactions by up to 20% of their similarity score.
# Enable only after SELECT COUNT(*) FROM feedback confirms >= 50 rows.
FEEDBACK_LEARNING_ENABLED=false
```

Do not modify any existing entries.
  </action>
  <verify>
```
grep "QUERY_EXPANSION_ENABLED\|FEEDBACK_LEARNING_ENABLED" .env.example
```
Expected: both variables appear in .env.example with value `false`.
  </verify>
  <done>
.env.example contains QUERY_EXPANSION_ENABLED=false and FEEDBACK_LEARNING_ENABLED=false with explanatory comments.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify intelligence field in live SSE response</name>
  <action>
Human confirms the intelligence metadata field appears in POST /api/chat SSE result events with both flags at their default-off values.
  </action>
  <verify>
    1. Start the backend locally: `cd /Users/sebastianhamers/Documents/TCS && uvicorn app.main:app --reload`

    2. Send a test chat request and inspect the SSE result event:
    ```
    curl -N -X POST http://localhost:8000/api/chat \
      -H "Content-Type: application/json" \
      -d '{"email":"test@example.com","query":"I need help with startup fundraising strategy"}' \
      2>/dev/null | grep '"event": "result"'
    ```

    3. Confirm the result event JSON contains an "intelligence" key:
    Expected SSE result event includes:
    `"intelligence": {"hyde_triggered": false, "hyde_bio": null, "feedback_applied": false}`
    (Both flags off by default, so both false)

    4. Optional — test with flag enabled:
    ```
    QUERY_EXPANSION_ENABLED=true uvicorn app.main:app --port 8001 &
    curl -N -X POST http://localhost:8001/api/chat \
      -H "Content-Type: application/json" \
      -d '{"email":"test@example.com","query":"help"}' \
      2>/dev/null | grep '"event": "result"'
    ```
    For a very short/vague query like "help", hyde_triggered may be true if the FAISS results are weak.

    5. Verify the backend starts with no import errors in the uvicorn logs.
  </verify>
  <done>
Human confirmed the intelligence field appears in the SSE result event. Backend starts without import errors. Type "approved" to continue, or describe issues found.
  </done>
  <resume-signal>Type "approved" when the intelligence field appears in the result event, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
1. `python -c "from app.routers.chat import router; print('OK')"` — import succeeds
2. `grep "intelligence" app/routers/chat.py` — shows intelligence in run_in_executor unpack AND in _sse() dict
3. `grep "from app.services.retriever import" app/routers/chat.py` — no output (replaced)
4. `grep "QUERY_EXPANSION_ENABLED\|FEEDBACK_LEARNING_ENABLED" .env.example` — both present with value false
5. POST /api/chat SSE result event includes "intelligence" field with hyde_triggered, hyde_bio, feedback_applied keys
</verification>

<success_criteria>
- chat.py calls retrieve_with_intelligence() instead of retrieve()
- SSE result event always includes "intelligence": {"hyde_triggered": bool, "hyde_bio": str|null, "feedback_applied": bool}
- Both flags default off — no behavioral change in production until Railway env vars are explicitly set
- .env.example documents both flags with guidance on when to enable each
- Human verified the intelligence field appears in a live SSE result event
</success_criteria>

<output>
After completion, create `.planning/phases/10-search-intelligence-layer/10-02-SUMMARY.md`
</output>
