---
phase: 05-email-gate-ux-show-expert-results-immediately-but-require-email-before-clicking-through-to-a-profile
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/hooks/useEmailGate.ts
  - frontend/src/components/EmailGate.tsx
  - frontend/src/components/ExpertCard.tsx
  - frontend/src/components/ChatMessage.tsx
  - frontend/src/App.tsx
autonomous: true
requirements: [EMAIL-GATE-01]

must_haves:
  truths:
    - "Expert cards appear greyed-out (grayscale + opacity-60) and non-clickable immediately when results are shown to a new user"
    - "Inline EmailGate form appears below the greyed-out cards on the most recent assistant message with experts only"
    - "Submitting a valid email instantly renders cards as fully clickable with no animation (instant state change)"
    - "The EmailGate disappears after submission with no re-appearance"
    - "Returning users (localStorage has email) see fully unlocked cards on page load with no gate shown"
    - "Locked cards render as <div> (not <a>) so keyboard users cannot tab-activate a locked link"
    - "useChat still receives PLACEHOLDER_EMAIL as fallback before gate submission so /api/chat requests remain valid"
  artifacts:
    - path: "frontend/src/hooks/useEmailGate.ts"
      provides: "localStorage-backed email gate state and submitEmail async function"
      exports: ["useEmailGate", "UseEmailGateReturn"]
    - path: "frontend/src/components/EmailGate.tsx"
      provides: "Inline email capture form with spinner, validation, privacy note"
      min_lines: 60
    - path: "frontend/src/components/ExpertCard.tsx"
      provides: "ExpertCard with locked prop — locked renders as greyed-out non-interactive div"
      contains: "locked"
    - path: "frontend/src/components/ChatMessage.tsx"
      provides: "Gate insertion below most recent expert message"
      contains: "EmailGate"
    - path: "frontend/src/App.tsx"
      provides: "useEmailGate hook wired; isUnlocked and submitEmail passed to ChatMessage"
      contains: "useEmailGate"
  key_links:
    - from: "frontend/src/App.tsx"
      to: "frontend/src/hooks/useEmailGate.ts"
      via: "useEmailGate() hook call"
      pattern: "useEmailGate"
    - from: "frontend/src/components/ChatMessage.tsx"
      to: "frontend/src/components/EmailGate.tsx"
      via: "conditional render when !isUnlocked and message is last expert message"
      pattern: "EmailGate"
    - from: "frontend/src/components/ExpertCard.tsx"
      to: "locked prop"
      via: "locked={!isUnlocked} passed from ChatMessage"
      pattern: "locked.*isUnlocked|locked=\\{!isUnlocked\\}"
    - from: "frontend/src/hooks/useEmailGate.ts"
      to: "/api/email-capture"
      via: "fire-and-forget fetch POST after localStorage write"
      pattern: "email-capture"
---

<objective>
Build the full email gate UX on the frontend: locked ExpertCard variant, inline EmailGate form, useEmailGate hook (localStorage persistence + backend POST), and wiring through ChatMessage and App.tsx.

Purpose: Users see expert results immediately (greyed-out) but cannot click through until they submit their email. Returning visitors bypass the gate entirely. Submitted email is persisted in localStorage and fired to the backend.

Output: Complete email gate UX — locked cards on first visit, inline form, instant unlock on submission, zero-friction returning user experience.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@frontend/src/components/ExpertCard.tsx
@frontend/src/components/ChatMessage.tsx
@frontend/src/App.tsx
@frontend/src/hooks/useChat.ts
@frontend/src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useEmailGate hook and EmailGate component</name>
  <files>frontend/src/hooks/useEmailGate.ts, frontend/src/components/EmailGate.tsx</files>
  <action>
    Create two new files. Zero new npm packages — all dependencies (React hooks, Tailwind, fetch) are already present.

    ---

    **frontend/src/hooks/useEmailGate.ts** — create fresh:

    ```typescript
    /**
     * useEmailGate — manages email gate unlock state.
     *
     * Design decisions:
     * - Lazy useState initializer reads localStorage synchronously on first render.
     *   This prevents a flash of "locked" state for returning users (no useEffect flash).
     * - submitEmail writes localStorage FIRST, then fires backend call.
     *   Backend failure is intentionally silent — localStorage is the UX source of truth.
     * - STORAGE_KEY is a stable string; changing it would force all existing users to re-submit.
     */
    import { useCallback, useState } from 'react'

    const STORAGE_KEY = 'tcs_gate_email'
    const API_URL = import.meta.env.VITE_API_URL ?? 'http://localhost:8000'

    export interface UseEmailGateReturn {
      isUnlocked: boolean
      email: string | null
      submitEmail: (email: string) => Promise<void>
    }

    export function useEmailGate(): UseEmailGateReturn {
      // Lazy initializer: runs synchronously before first render — no flash of locked state.
      const [email, setEmail] = useState<string | null>(() => {
        return localStorage.getItem(STORAGE_KEY)
      })

      const isUnlocked = email !== null

      const submitEmail = useCallback(async (submittedEmail: string) => {
        // Write localStorage FIRST — this is the source of truth for unlock.
        // UI is unlocked immediately regardless of backend outcome.
        localStorage.setItem(STORAGE_KEY, submittedEmail)
        setEmail(submittedEmail)

        // Fire-and-forget: backend failure does NOT re-lock the gate.
        try {
          await fetch(`${API_URL}/api/email-capture`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: submittedEmail }),
          })
        } catch {
          // Intentional: backend failure is silent. User is already unlocked via localStorage.
          // If Sentry is configured, errors will be captured automatically by the global handler.
        }
      }, [])

      return { isUnlocked, email, submitEmail }
    }
    ```

    ---

    **frontend/src/components/EmailGate.tsx** — create fresh:

    ```typescript
    /**
     * EmailGate — inline email capture form rendered below locked Expert Cards.
     *
     * Design decisions:
     * - No modal, no slide-in panel — plain JSX in the chat message flow (per CONTEXT.md)
     * - Mandatory gate: no dismiss, no skip, no close button
     * - Unlock is instant: parent unmounts this component on isUnlocked=true (no fade)
     * - Loading state: spinner + disabled input while backend call is in flight
     * - Backend failure: onSubmit (useEmailGate.submitEmail) unlocks on localStorage write;
     *   this component just shows loading until the Promise resolves
     * - Uses animate-spin pattern matching existing ChatInput.tsx spinner
     */
    import { useState, type FormEvent } from 'react'

    interface Props {
      onSubmit: (email: string) => Promise<void>
    }

    export default function EmailGate({ onSubmit }: Props) {
      const [value, setValue] = useState('')
      const [error, setError] = useState<string | null>(null)
      const [loading, setLoading] = useState(false)

      const handleSubmit = async (e: FormEvent) => {
        e.preventDefault()
        const trimmed = value.trim()

        // Client-side validation: simple regex is sufficient for UX feedback.
        // Server-side Pydantic EmailStr is the authoritative validator.
        const isValidEmail = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(trimmed)
        if (!isValidEmail) {
          setError('Please enter a valid email address.')
          return
        }

        setError(null)
        setLoading(true)
        try {
          await onSubmit(trimmed)
          // Parent sets isUnlocked=true → this component unmounts, cleaning all form state
        } finally {
          setLoading(false)
        }
      }

      return (
        <div className="mt-4 rounded-2xl border border-neutral-200 bg-neutral-50 p-4">
          <p className="text-sm font-semibold text-neutral-900 mb-1">
            Unlock expert profiles
          </p>
          <p className="text-xs text-neutral-500 mb-3">
            Enter your email to view full profiles and connect with experts.
          </p>
          <form onSubmit={handleSubmit} noValidate>
            <input
              type="email"
              value={value}
              onChange={(e) => { setValue(e.target.value); setError(null) }}
              disabled={loading}
              placeholder="you@example.com"
              aria-label="Email address"
              aria-required="true"
              aria-invalid={error ? 'true' : 'false'}
              aria-describedby={error ? 'email-gate-error' : undefined}
              className="w-full rounded-xl border border-neutral-300 px-4 py-2.5 text-sm text-neutral-900 placeholder-neutral-400 focus:outline-none focus:ring-2 focus:ring-brand-purple focus:border-transparent disabled:bg-neutral-100 disabled:cursor-not-allowed mb-2"
            />
            {error && (
              <p id="email-gate-error" className="text-xs text-red-500 mb-2" role="alert">
                {error}
              </p>
            )}
            <button
              type="submit"
              disabled={loading || !value.trim()}
              className="w-full rounded-xl bg-brand-purple text-white text-sm font-semibold py-2.5 hover:bg-purple-700 active:bg-purple-800 transition-colors disabled:bg-neutral-300 disabled:cursor-not-allowed flex items-center justify-center gap-2"
            >
              {loading ? (
                <>
                  <svg
                    className="animate-spin w-4 h-4 text-white"
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                    aria-hidden="true"
                  >
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v8H4z" />
                  </svg>
                  Unlocking…
                </>
              ) : (
                'Unlock profiles'
              )}
            </button>
            <p className="text-xs text-neutral-400 text-center mt-2">We'll never spam you.</p>
          </form>
        </div>
      )
    }
    ```

    Both files use `import type` syntax for interface imports (per existing project convention — verbatimModuleSyntax in tsconfig.app.json). Note `import { useState, type FormEvent }` in EmailGate.tsx is correct — `FormEvent` is a type import, `useState` is a value import.
  </action>
  <verify>
    Run TypeScript check on new files:
    `cd /Users/sebastianhamers/Documents/TCS/frontend && npx tsc --noEmit --project tsconfig.app.json 2>&1 | grep -E "useEmailGate|EmailGate"`
    Expected: no errors mentioning these files.

    Also verify exports resolve:
    `cd /Users/sebastianhamers/Documents/TCS/frontend && node -e "console.log('files exist')" && ls src/hooks/useEmailGate.ts src/components/EmailGate.tsx`
    Expected: both files listed.
  </verify>
  <done>useEmailGate.ts and EmailGate.tsx exist; TypeScript compiles both without errors; useEmailGate exports isUnlocked (boolean), email (string|null), submitEmail (async); EmailGate renders form with "Unlock profiles" button, privacy note, spinner on loading.</done>
</task>

<task type="auto">
  <name>Task 2: Wire email gate into ExpertCard, ChatMessage, and App.tsx</name>
  <files>frontend/src/components/ExpertCard.tsx, frontend/src/components/ChatMessage.tsx, frontend/src/App.tsx</files>
  <action>
    Modify three existing files to wire the email gate end-to-end.

    ---

    **frontend/src/components/ExpertCard.tsx** — add `locked` prop:

    Change the Props interface from:
    ```typescript
    interface Props {
      expert: Expert
    }
    ```
    To:
    ```typescript
    interface Props {
      expert: Expert
      locked?: boolean
    }
    ```

    Change the function signature from:
    ```typescript
    export default function ExpertCard({ expert }: Props) {
    ```
    To:
    ```typescript
    export default function ExpertCard({ expert, locked = false }: Props) {
    ```

    Add the locked render branch BEFORE the existing `if (profileUrl)` block. Insert after the closing `</div>` of the `inner` variable (after line `)`):

    ```typescript
      if (locked) {
        return (
          <div
            className="block w-full rounded-2xl border border-neutral-200 bg-white p-4 grayscale opacity-60 pointer-events-none select-none"
            aria-hidden="true"
          >
            {inner}
          </div>
        )
      }
    ```

    The full render block order becomes: locked branch → profileUrl branch → default div branch. No changes to the `inner` JSX or any existing classes.

    Note: `aria-hidden="true"` on locked cards prevents screen readers from announcing non-interactive content as a link. The keyboard-accessible path to unlock is the EmailGate form below.

    ---

    **frontend/src/components/ChatMessage.tsx** — add gate insertion:

    Add imports at the top (after existing imports):
    ```typescript
    import EmailGate from './EmailGate'
    ```

    Change the Props interface from:
    ```typescript
    interface Props {
      message: Message
      thinkingQuote?: string
    }
    ```
    To:
    ```typescript
    interface Props {
      message: Message
      thinkingQuote?: string
      isUnlocked: boolean
      onSubmitEmail: (email: string) => Promise<void>
      isLastExpertMessage: boolean
    }
    ```

    Change the function signature from:
    ```typescript
    export default function ChatMessage({ message, thinkingQuote }: Props) {
    ```
    To:
    ```typescript
    export default function ChatMessage({ message, thinkingQuote, isUnlocked, onSubmitEmail, isLastExpertMessage }: Props) {
    ```

    Replace the expert cards section (the `{!isUser && message.experts && ...}` block) with:
    ```typescript
            {/* Expert Cards — locked (greyed) until email submitted; gate appears on last expert message only */}
            {!isUser && message.experts && message.experts.length > 0 && (
              <div className="mt-3 space-y-3">
                {message.experts.map((expert, i) => (
                  <ExpertCard
                    key={expert.profile_url ?? `${expert.name}-${i}`}
                    expert={expert}
                    locked={!isUnlocked}
                  />
                ))}
                {!isUnlocked && isLastExpertMessage && (
                  <EmailGate onSubmit={onSubmitEmail} />
                )}
              </div>
            )}
    ```

    Gate logic: locked cards appear on ALL assistant messages with experts when !isUnlocked. The EmailGate form appears ONLY on the last expert message (isLastExpertMessage=true) — prevents duplicate forms in multi-turn chat.

    ---

    **frontend/src/App.tsx** — wire useEmailGate:

    Add import at the top (after existing hooks import):
    ```typescript
    import { useEmailGate } from './hooks/useEmailGate'
    ```

    Inside the App component, add useEmailGate call after the useChat line:
    ```typescript
      const { isUnlocked, email, submitEmail } = useEmailGate()
    ```

    Update the useChat call to use real email when available (keeping PLACEHOLDER_EMAIL as fallback for pre-gate chat requests):
    ```typescript
      const { messages, status, sendMessage, retryLast } = useChat({
        email: email ?? PLACEHOLDER_EMAIL,
      })
    ```

    In the messages.map render, compute `isLastExpertMessage` and pass new props to ChatMessage. Replace the existing map block:

    Find the existing messages.map block that renders ChatMessage and replace:
    ```typescript
              {messages.map((message, i) => {
                const isLastAssistant =
                  message.role === 'assistant' && i === messages.length - 1
                return (
                  <ChatMessage
                    key={message.id}
                    message={message}
                    thinkingQuote={
                      isLastAssistant && status === 'thinking'
                        ? THINKING_QUOTES[quoteIndex]
                        : undefined
                    }
                  />
                )
              })}
    ```

    With:
    ```typescript
              {messages.map((message, i) => {
                const isLastAssistant =
                  message.role === 'assistant' && i === messages.length - 1
                // Find index of the last message with experts for gate placement
                const lastExpertMsgIndex = messages.reduce(
                  (last, m, idx) =>
                    m.role === 'assistant' && m.experts && m.experts.length > 0 ? idx : last,
                  -1
                )
                const isLastExpertMessage = i === lastExpertMsgIndex
                return (
                  <ChatMessage
                    key={message.id}
                    message={message}
                    thinkingQuote={
                      isLastAssistant && status === 'thinking'
                        ? THINKING_QUOTES[quoteIndex]
                        : undefined
                    }
                    isUnlocked={isUnlocked}
                    onSubmitEmail={submitEmail}
                    isLastExpertMessage={isLastExpertMessage}
                  />
                )
              })}
    ```

    The `lastExpertMsgIndex` computation runs inside the map callback — it is correct to call `.reduce` on the messages array inside each iteration because messages array length is small (< 50 items) and re-computation is cheap. If performance becomes a concern in phase 6+, memoize with useMemo.
  </action>
  <verify>
    1. TypeScript check:
       `cd /Users/sebastianhamers/Documents/TCS/frontend && npx tsc --noEmit --project tsconfig.app.json`
       Expected: zero errors.

    2. Dev build:
       `cd /Users/sebastianhamers/Documents/TCS/frontend && npx vite build 2>&1 | tail -5`
       Expected: "built in X.XXs" — no build errors.

    3. File content check:
       `grep -n "locked" /Users/sebastianhamers/Documents/TCS/frontend/src/components/ExpertCard.tsx`
       Expected: shows locked prop and locked branch.

       `grep -n "EmailGate\|isUnlocked\|isLastExpertMessage" /Users/sebastianhamers/Documents/TCS/frontend/src/components/ChatMessage.tsx`
       Expected: shows EmailGate import and conditional render.

       `grep -n "useEmailGate\|isUnlocked\|submitEmail" /Users/sebastianhamers/Documents/TCS/frontend/src/App.tsx`
       Expected: shows hook call and props passed to ChatMessage.
  </verify>
  <done>TypeScript compiles without errors; vite build succeeds; ExpertCard has locked prop that renders greyed-out div; ChatMessage imports EmailGate and conditionally renders it on last expert message; App.tsx uses useEmailGate and passes isUnlocked + submitEmail to ChatMessage.</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `cd /Users/sebastianhamers/Documents/TCS/frontend && npx tsc --noEmit --project tsconfig.app.json` — zero errors
2. `cd /Users/sebastianhamers/Documents/TCS/frontend && npx vite build` — builds cleanly
3. All 5 frontend files exist and contain expected patterns (locked, EmailGate, useEmailGate, isUnlocked, submitEmail)
</verification>

<success_criteria>
- useEmailGate hook reads localStorage synchronously (lazy initializer — no flash for returning users)
- submitEmail writes localStorage FIRST, then fires backend POST (unlock-on-localStorage policy)
- ExpertCard renders as greyed-out non-interactive div when locked=true (grayscale opacity-60 pointer-events-none)
- EmailGate renders only on the last assistant message with experts (not on all messages)
- App.tsx wires useEmailGate and passes isUnlocked/submitEmail through to ChatMessage
- PLACEHOLDER_EMAIL remains fallback in useChat for pre-gate chat requests
- TypeScript zero errors, vite build passes
</success_criteria>

<output>
After completion, create `.planning/phases/05-email-gate-ux-show-expert-results-immediately-but-require-email-before-clicking-through-to-a-profile/05-02-SUMMARY.md`
</output>
