---
phase: 05-email-gate-ux-show-expert-results-immediately-but-require-email-before-clicking-through-to-a-profile
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/models.py
  - app/routers/email_capture.py
  - app/main.py
autonomous: true
requirements: [EMAIL-GATE-01]

must_haves:
  truths:
    - "POST /api/email-capture accepts a valid email and returns {status: ok} with 200"
    - "Duplicate email submissions are silently ignored (idempotent — no 500 or 409 errors)"
    - "Invalid email format returns 422 from Pydantic EmailStr validation"
    - "The email_leads table is created in the SQLite DB on server startup"
  artifacts:
    - path: "app/routers/email_capture.py"
      provides: "POST /api/email-capture endpoint with idempotent insert"
      exports: ["router"]
    - path: "app/models.py"
      provides: "EmailLead ORM model"
      contains: "class EmailLead"
    - path: "app/main.py"
      provides: "email_capture router registered in FastAPI app"
      contains: "email_capture"
  key_links:
    - from: "app/routers/email_capture.py"
      to: "app/models.EmailLead"
      via: "SQLAlchemy dialect insert with on_conflict_do_nothing"
      pattern: "on_conflict_do_nothing"
    - from: "app/main.py"
      to: "app/routers/email_capture.router"
      via: "app.include_router(email_capture.router)"
      pattern: "include_router.*email_capture"
---

<objective>
Add the backend lead capture infrastructure for the email gate. Introduces an EmailLead ORM model, a new POST /api/email-capture endpoint, and wires it into the FastAPI app.

Purpose: The email gate frontend needs a backend endpoint to store submitted emails as leads in the database. The endpoint must be idempotent (duplicate emails are silently ignored) so returning-visitor re-submissions don't error.

Output: Working POST /api/email-capture endpoint that stores emails in email_leads table; server startup creates the table automatically via create_all.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@app/models.py
@app/main.py
@app/routers/chat.py
@app/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EmailLead model to app/models.py</name>
  <files>app/models.py</files>
  <action>
    Append the EmailLead SQLAlchemy ORM model to app/models.py. Follow exact same mapped_column patterns as the existing Conversation model.

    Add after the Conversation class:

    ```python
    class EmailLead(Base):
        """
        Stores email addresses submitted via the email gate for lead capture.
        Unique constraint on email prevents duplicates — use INSERT OR IGNORE (on_conflict_do_nothing)
        at the query layer for idempotency.

        # Migration note: if moving to Postgres, switch to sqlalchemy.dialects.postgresql.insert
        """
        __tablename__ = "email_leads"

        id: Mapped[int] = mapped_column(primary_key=True, index=True)
        email: Mapped[str] = mapped_column(String(320), unique=True, nullable=False, index=True)
        created_at: Mapped[datetime.datetime] = mapped_column(
            DateTime, default=datetime.datetime.utcnow, nullable=False
        )
    ```

    No changes to Conversation model or imports. The existing `import datetime`, `String`, `DateTime`, `Mapped`, `mapped_column`, and `Base` imports already cover all needed symbols.
  </action>
  <verify>
    Run: `cd /Users/sebastianhamers/Documents/TCS && python -c "from app.models import EmailLead, Conversation; print('EmailLead OK:', EmailLead.__tablename__)"`
    Expected output: `EmailLead OK: email_leads`
    No import errors, no attribute errors.
  </verify>
  <done>EmailLead model importable from app.models; __tablename__ is "email_leads"; email column has unique=True; created_at uses datetime.datetime.utcnow default.</done>
</task>

<task type="auto">
  <name>Task 2: Create /api/email-capture router and wire into main.py</name>
  <files>app/routers/email_capture.py, app/main.py</files>
  <action>
    Create app/routers/email_capture.py as a new file. Then modify app/main.py to register the new router.

    **app/routers/email_capture.py** — create fresh:

    ```python
    """
    Email lead capture endpoint.

    POST /api/email-capture — stores submitted email in email_leads table.
    Idempotent: duplicate emails are silently ignored via INSERT OR IGNORE.

    Backend failure policy: this endpoint is fire-and-forget from the frontend.
    The frontend unlocks on localStorage write regardless of this call's outcome.

    Import note: must use sqlalchemy.dialects.sqlite.insert (NOT sqlalchemy.insert)
    for on_conflict_do_nothing support. When migrating to Postgres, switch to
    sqlalchemy.dialects.postgresql.insert — API is identical.
    """
    from fastapi import APIRouter, Depends
    from pydantic import BaseModel, EmailStr
    from sqlalchemy.dialects.sqlite import insert
    from sqlalchemy.orm import Session

    from app.database import get_db
    from app.models import EmailLead

    router = APIRouter()


    class EmailCaptureRequest(BaseModel):
        email: EmailStr


    @router.post("/api/email-capture", status_code=200)
    def capture_email(body: EmailCaptureRequest, db: Session = Depends(get_db)):
        """
        Store email for lead capture. Silently ignores duplicate emails.
        Returns {"status": "ok"} on success (including duplicates).
        """
        stmt = (
            insert(EmailLead)
            .values(email=str(body.email))
            .on_conflict_do_nothing(index_elements=["email"])
        )
        db.execute(stmt)
        db.commit()
        return {"status": "ok"}
    ```

    **app/main.py** — add the email_capture router import and registration. Find the existing imports block:
    ```python
    from app.routers import chat, health
    ```
    Change to:
    ```python
    from app.routers import chat, email_capture, health
    ```

    Find the routes section:
    ```python
    # --- Routes ---
    app.include_router(health.router)
    app.include_router(chat.router)
    ```
    Change to:
    ```python
    # --- Routes ---
    app.include_router(health.router)
    app.include_router(chat.router)
    app.include_router(email_capture.router)
    ```

    No other changes to main.py. The `Base.metadata.create_all(bind=engine)` call in lifespan already creates all registered models including the new EmailLead table — no additional startup code needed.
  </action>
  <verify>
    1. Syntax check: `cd /Users/sebastianhamers/Documents/TCS && python -c "from app.routers.email_capture import router; print('Router OK:', router)"`
       Expected: prints router object, no errors.

    2. Start server and test endpoint:
       `cd /Users/sebastianhamers/Documents/TCS && uvicorn app.main:app --port 8001 &amp; sleep 3`

       Test valid email:
       `curl -s -X POST http://localhost:8001/api/email-capture -H "Content-Type: application/json" -d '{"email":"test@example.com"}' | python3 -m json.tool`
       Expected: `{"status": "ok"}`

       Test duplicate (same email again):
       `curl -s -X POST http://localhost:8001/api/email-capture -H "Content-Type: application/json" -d '{"email":"test@example.com"}' | python3 -m json.tool`
       Expected: `{"status": "ok"}` (not an error)

       Test invalid email:
       `curl -s -X POST http://localhost:8001/api/email-capture -H "Content-Type: application/json" -d '{"email":"notanemail"}' | python3 -m json.tool`
       Expected: 422 response with Pydantic validation error.

       Kill test server: `pkill -f "uvicorn app.main:app --port 8001"`

    3. Verify route registered: `cd /Users/sebastianhamers/Documents/TCS && python -c "from app.main import app; routes = [r.path for r in app.routes]; print(routes); assert '/api/email-capture' in routes"`
  </verify>
  <done>POST /api/email-capture returns 200 {"status":"ok"} for valid emails; duplicate submissions return 200 (not error); invalid emails return 422; route appears in FastAPI route list; email_leads table created on server start.</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `python -c "from app.models import EmailLead; print(EmailLead.__table__.columns.keys())"` — shows [id, email, created_at]
2. `python -c "from app.main import app; routes = [r.path for r in app.routes]; assert '/api/email-capture' in routes; print('Route registered')"` — passes
3. `ruff check app/models.py app/routers/email_capture.py app/main.py` — zero errors
</verification>

<success_criteria>
- EmailLead ORM model exists in app/models.py with email (unique), created_at columns
- POST /api/email-capture endpoint returns 200 {"status":"ok"} for valid emails
- Duplicate emails silently ignored (on_conflict_do_nothing)
- Invalid emails return 422 from Pydantic EmailStr
- email_capture router registered in app/main.py
- ruff check passes on all modified files
</success_criteria>

<output>
After completion, create `.planning/phases/05-email-gate-ux-show-expert-results-immediately-but-require-email-before-clicking-through-to-a-profile/05-01-SUMMARY.md`
</output>
