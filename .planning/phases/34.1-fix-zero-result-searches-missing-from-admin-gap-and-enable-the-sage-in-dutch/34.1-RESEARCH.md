# Phase 34.1: Fix zero-result searches missing from admin gap and enable the sage in dutch - Research

**Researched:** 2026-02-23
**Domain:** Backend gap detection (SQLAlchemy/SQLite NULL handling) + LLM-based language detection and translation (Gemini Python SDK)
**Confidence:** HIGH

---

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Gap detection fix:**
- Fix queries only — add `OR top_match_score IS NULL` to all gap conditions; do NOT change how chat.py stores NULL
- Apply consistently across ALL gap-checking locations: Gaps page, stats counters, intelligence stats, searches gap_flag filter, daily trend SQL, and CSV exports
- The `_is_gap` Python helper must also treat NULL as a gap (currently explicitly excludes it)

**Dutch Sage — language detection:**
- Auto-detect Dutch input — no language toggle or selector in the UI
- Dutch support scoped to Sage co-pilot only — main grid/filters remain English-only
- Dutch only for now — no need for a generic multi-language framework

**Dutch Sage — query matching:**
- Translate Dutch query to English before FAISS embedding search — ensures best match quality against English expert bios
- Translation happens server-side before the embedding step

**Dutch Sage — response language:**
- When user writes in Dutch, Sage responds in Dutch (narrative/explanation)
- Expert data (names, titles, bios, tags) stays in English within the Dutch response — they're proper data, not translatable content

**Dutch Sage — UI scope:**
- All UI elements (placeholders, buttons, labels, empty states) stay in English
- Only the Sage conversation content (user query + Sage response) is in Dutch

### Claude's Discretion
- Best Score column display for NULL scores (dash vs 0.000 — pick what's most readable)
- Visual treatment of zero-result gaps in the table (subtle badge or no special treatment)
- Whether to show a language detection indicator (NL badge) or keep it seamless

### Deferred Ideas (OUT OF SCOPE)
None — discussion stayed within phase scope
</user_constraints>

---

## Summary

Phase 34.1 has two distinct fixes. The first is a backend-only bug: every SQL gap condition in `app/routers/admin.py` uses `top_match_score < GAP_THRESHOLD`, which SQLite evaluates as `NULL < 0.60 = NULL` (falsy), so rows where `top_match_score IS NULL` are silently excluded from all gap queries, counters, daily trends, and CSV exports. There are exactly 8 call sites to patch plus the `_is_gap()` Python helper. No schema or model changes are needed, and `chat.py` intentionally stores NULL (no candidates found), so the storage side is correct.

The second fix enables Dutch-language support in the Sage co-pilot. The existing architecture (two-turn Gemini function calling in `pilot_service.py`) already uses the Gemini Python SDK (`google-genai`). The cleanest implementation is to use the same Gemini client already wired up to (a) detect language at the top of `run_pilot()`, (b) translate the query to English before passing it to `run_explore()`, and (c) inject Dutch instruction into the system prompt when Dutch is detected. No new dependencies are needed. No frontend changes are required beyond the "Claude's Discretion" items about an optional NL badge.

**Primary recommendation:** Fix all 8 NULL gap conditions in a single backend pass; add language detection + translation as two Gemini helper calls at the top of `run_pilot()` with the Dutch override injected into the system prompt for turn 2.

---

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| SQLAlchemy ORM | 2.0.* | Query construction | Already used for all gap queries |
| SQLite (via SQLAlchemy) | — | Database | Railway volume; all gaps are SQLite queries |
| google-genai | 1.64.* | Gemini API client | Already used in `pilot_service.py` — no new dep |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| structlog | 24.2.* | Logging | Already used; log lang_detected events |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Gemini for language detection | `langdetect` Python package | langdetect is not in requirements.txt; adding a new dep is unnecessary since Gemini client is already present and Gemini is more accurate on short queries |
| Gemini for translation | Google Cloud Translate API | Requires separate API key and billing; Gemini handles both detection and translation in one call |

**Installation:** No new packages required.

---

## Architecture Patterns

### Part 1: Gap Detection Fix

#### All locations requiring NULL fix

There are **8 call sites** in `app/routers/admin.py` where the gap condition must be extended:

**Location 1 — `_is_gap()` helper (line 204–208):**
```python
# CURRENT (broken)
def _is_gap(row: Conversation) -> bool:
    return (
        row.top_match_score is not None and row.top_match_score < GAP_THRESHOLD
    ) or row.response_type == "clarification"

# FIXED
def _is_gap(row: Conversation) -> bool:
    return (
        row.top_match_score is None or row.top_match_score < GAP_THRESHOLD
    ) or row.response_type == "clarification"
```

**Location 2 — `get_stats()` gap_count query (line 275–278):**
```python
# CURRENT
gap_count = db.scalar(
    select(func.count()).select_from(Conversation).where(
        (Conversation.top_match_score < GAP_THRESHOLD)
        | (Conversation.response_type == "clarification")
    )
) or 0

# FIXED
gap_count = db.scalar(
    select(func.count()).select_from(Conversation).where(
        Conversation.top_match_score.is_(None)
        | (Conversation.top_match_score < GAP_THRESHOLD)
        | (Conversation.response_type == "clarification")
    )
) or 0
```

**Location 3 — `get_intelligence_stats()` gap_count query (line 339–344):**
Same pattern as Location 2.

**Location 4 — `get_intelligence_stats()` daily trend raw SQL (line 372):**
```sql
-- CURRENT (broken — NULL < threshold is NULL, counts as 0)
SUM(CASE WHEN top_match_score < :threshold OR response_type = 'clarification' THEN 1 ELSE 0 END) AS gaps

-- FIXED
SUM(CASE WHEN top_match_score IS NULL OR top_match_score < :threshold OR response_type = 'clarification' THEN 1 ELSE 0 END) AS gaps
```

**Location 5 — `get_searches()` gap_flag=True filter (line 495–499):**
```python
# CURRENT
if gap_flag is True:
    stmt = stmt.where(
        (Conversation.top_match_score < GAP_THRESHOLD)
        | (Conversation.response_type == "clarification")
    )
elif gap_flag is False:
    stmt = stmt.where(
        (Conversation.top_match_score >= GAP_THRESHOLD)
        & (Conversation.response_type != "clarification")
    )

# FIXED
if gap_flag is True:
    stmt = stmt.where(
        Conversation.top_match_score.is_(None)
        | (Conversation.top_match_score < GAP_THRESHOLD)
        | (Conversation.response_type == "clarification")
    )
elif gap_flag is False:
    stmt = stmt.where(
        Conversation.top_match_score.is_not(None)
        & (Conversation.top_match_score >= GAP_THRESHOLD)
        & (Conversation.response_type != "clarification")
    )
```

**Location 6 — `get_gaps()` WHERE clause (line 560–563):**
```python
# FIXED
.where(
    Conversation.top_match_score.is_(None)
    | (Conversation.top_match_score < GAP_THRESHOLD)
    | (Conversation.response_type == "clarification")
)
```

**Location 7 — `export_searches_csv()` gap_flag filter (line 1101–1110):**
Same pattern as Location 5.

**Location 8 — `export_gaps_csv()` WHERE clause (line 1328–1331):**
Same pattern as Location 6.

#### SQLAlchemy NULL-safe comparison patterns
```python
# Source: SQLAlchemy 2.0 ORM docs — Column operators
# IS NULL
Conversation.top_match_score.is_(None)

# IS NOT NULL
Conversation.top_match_score.is_not(None)

# Combining NULL-OR-less-than in ORM
Conversation.top_match_score.is_(None) | (Conversation.top_match_score < threshold)

# In raw SQL strings (for daily trend)
"top_match_score IS NULL OR top_match_score < :threshold"
```

#### Best Score display for NULL in GapsTable frontend
- `null` from Python serializes to JSON `null`, arrives in TypeScript as `null`
- Recommended display: `row.best_score != null ? row.best_score.toFixed(3) : '—'`
- The `—` (em dash) is more readable than `0.000` which implies a near-miss score

---

### Part 2: Dutch Sage Implementation

#### Where language detection and translation live

All Sage logic is in `app/services/pilot_service.py`, `run_pilot()` function. The entry point receives `message: str` (the raw user text). Language detection and translation must happen at the **top of `run_pilot()`**, before anything else, so the translated query is used throughout:

1. FAISS search via `run_explore()` receives the English translation
2. The system prompt is injected with Dutch instruction when Dutch is detected
3. Turn 1 and Turn 2 both use the modified system prompt

```python
# Pseudocode — at top of run_pilot()
detected_lang, translated_message = _detect_and_translate(message, client)
# Use translated_message for all search/filter operations
# Use detected_lang to conditionally modify system_instruction
```

#### Gemini-based language detection + translation

The existing `_get_client()` already returns a `genai.Client`. A single Gemini call handles both detection and translation atomically:

```python
def _detect_and_translate(message: str, client) -> tuple[str, str]:
    """
    Detect language and translate to English if not already English.
    Returns (detected_lang: 'nl'|'en'|'other', english_message: str).
    Dutch short-circuits quickly — one small model call.
    """
    prompt = (
        f"Detect the language of this text and if it's Dutch (NL), translate it to English. "
        f"Respond ONLY as JSON: {{\"lang\": \"nl\"|\"en\"|\"other\", \"english\": \"<translation or original>\"}}.\n"
        f"Text: {message}"
    )
    try:
        resp = client.models.generate_content(
            model="gemini-2.0-flash-lite",  # Fast/cheap — not gemini-2.5-flash
            contents=prompt,
            config=types.GenerateContentConfig(
                response_mime_type="application/json",
            ),
        )
        data = json.loads(resp.text)
        lang = data.get("lang", "en")
        english = data.get("english", message)
        return lang, english
    except Exception as e:
        log.warning("pilot: language detection failed", error=str(e))
        return "en", message  # Safe fallback — treat as English
```

**Model choice note:** Use `gemini-2.0-flash-lite` (or the current cheapest/fastest Gemini variant available) for this detection step — it's a structured JSON extraction task, not a complex reasoning task. This minimizes latency added per message. The main Sage turns continue using `gemini-2.5-flash` (GENERATION_MODEL).

#### System prompt modification for Dutch

Inject Dutch language instruction conditionally:

```python
# After language detection, modify system_instruction if Dutch:
if detected_lang == "nl":
    system_instruction = system_instruction + (
        "\n\nIMPORTANT: The user is writing in Dutch. You MUST respond in Dutch. "
        "Expert names, job titles, and company names are proper nouns — keep them in English. "
        "All Sage narrative and explanation must be in Dutch."
    )
```

#### Message flow for Dutch users

```
User sends: "vind me een fintech expert"
    ↓
_detect_and_translate() → lang="nl", english="find me a fintech expert"
    ↓
run_explore(query="find me a fintech expert", ...) → FAISS matches English bios correctly
    ↓
fn_response includes top_experts in English (names, titles, rates)
    ↓
Turn 2 Gemini call uses Dutch system prompt → response in Dutch
    ↓
User sees: "Ik heb een aantal fintech experts gevonden — Sarah Chen (CFO) en Mark Rutten ($150/hr) zijn het waard..."
```

#### What NOT to change in the frontend

Per locked decisions, the frontend requires zero changes for Dutch support:
- `SageInput` placeholder ("Ask Sage...") stays in English
- `SagePanel` header ("Sage", "AI assistant") stays in English
- `SAGE_GREETING` constant stays in English
- Dutch users will simply see their Dutch message followed by Dutch response — the UI chrome stays English

#### Claude's Discretion: NL language indicator

Whether to show an "NL" badge in the Sage message bubble when Dutch is detected is at Claude's discretion. Recommendation: **skip it for this phase** — it adds UI complexity for minimal user benefit. The seamless approach (Dutch in = Dutch out) is self-explanatory. If added later, it would be a small badge on the assistant message bubble component (`SageMessage.tsx`).

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Language detection | Custom regex/heuristic word-list | Gemini structured JSON response | Dutch words like "een", "de", "van" are short and could false-positive; Gemini is accurate on context, not just token matching |
| Translation | Word-by-word lookup table | Gemini translation prompt | Dutch idiomatic expressions and domain-specific terms need semantic translation, not literal substitution |
| NULL-safe SQL | Custom Python filtering | SQLAlchemy `.is_(None)` / raw SQL `IS NULL` | Database handles NULLs correctly only via proper NULL operators; Python comparison `== None` on a column object produces wrong ORM predicates |

**Key insight:** `column < value` in SQL when column is NULL evaluates to UNKNOWN/NULL, which is treated as false in WHERE clauses. This is standard SQL behavior. Always use `IS NULL` explicitly for NULL checks.

---

## Common Pitfalls

### Pitfall 1: SQLite NULL comparison behavior
**What goes wrong:** `WHERE top_match_score < 0.60` silently excludes rows where `top_match_score IS NULL`. SQLite's three-value logic evaluates `NULL < 0.60` as `NULL`, which is falsy in a WHERE clause.
**Why it happens:** Developers often assume `< threshold` catches "low or missing" scores. In SQL, NULL means "unknown", so comparison operators with NULL always produce NULL.
**How to avoid:** Always write `IS NULL OR column < threshold` when NULL should be treated as a gap.
**Warning signs:** Gap count appears lower than expected; clarification-type queries appear but NULL-score queries do not.

### Pitfall 2: SQLAlchemy ORM vs raw SQL NULL handling
**What goes wrong:** Using `Conversation.top_match_score == None` in SQLAlchemy ORM produces `top_match_score = NULL` which is always false in SQL. Use `Conversation.top_match_score.is_(None)` instead.
**How to avoid:** Use `.is_(None)` for ORM NULL checks, `IS NULL` in raw SQL strings.

### Pitfall 3: gap_flag=False filter must also be updated
**What goes wrong:** When fixing `gap_flag=True` to include NULLs, the `gap_flag=False` filter must also exclude NULLs explicitly. Without `IS NOT NULL`, rows with NULL score would match neither gap nor non-gap filter — or worse, appear in both.
**How to avoid:** Update both the `gap_flag is True` AND `gap_flag is False` branches together.

### Pitfall 4: Gemini model for detection adds latency to every Sage turn
**What goes wrong:** Using a heavy model (gemini-2.5-flash) for language detection adds 500-1500ms to every single Sage message, even English ones.
**How to avoid:** Use `gemini-2.0-flash-lite` or equivalent fast model for the detection/translation step. Cache result if needed (not necessary for this phase since history is per-session).

### Pitfall 5: Dutch query must be translated before FAISS, not after
**What goes wrong:** If the Dutch query string is passed directly to `run_explore()`, the embedding is generated from Dutch text against an English-language FAISS index — producing poor matches.
**Why it happens:** The FAISS index was built from English expert bios and descriptions.
**How to avoid:** Translate FIRST, then call `run_explore()` with the English translation.

### Pitfall 6: History messages are already-translated English in subsequent turns
**What goes wrong:** On turn 2+, history messages were previously Dutch but are now stored as user-sent text. Only the current message needs detection/translation, not the history.
**How to avoid:** Detect/translate only `message` (current turn), not the history array. History is passed verbatim to Gemini — the system prompt's Dutch instruction handles continuity.

---

## Code Examples

### SQLAlchemy NULL-safe gap condition (ORM)
```python
# Source: SQLAlchemy 2.0 column_elements documentation
from sqlalchemy import select, func

gap_count = db.scalar(
    select(func.count()).select_from(Conversation).where(
        Conversation.top_match_score.is_(None)
        | (Conversation.top_match_score < GAP_THRESHOLD)
        | (Conversation.response_type == "clarification")
    )
) or 0
```

### SQLAlchemy NULL-safe gap condition (raw SQL)
```sql
-- In get_intelligence_stats() daily trend
SUM(CASE WHEN top_match_score IS NULL
          OR top_match_score < :threshold
          OR response_type = 'clarification'
     THEN 1 ELSE 0 END) AS gaps
```

### Updated _is_gap() helper
```python
def _is_gap(row: Conversation) -> bool:
    """Return True if the conversation qualifies as a gap.
    NULL top_match_score = no candidates found = gap by definition.
    """
    return (
        row.top_match_score is None or row.top_match_score < GAP_THRESHOLD
    ) or row.response_type == "clarification"
```

### Gemini structured JSON detection + translation
```python
import json as _json

def _detect_and_translate(message: str, client) -> tuple[str, str]:
    """Detect language; translate Dutch→English. Returns (lang, english_text)."""
    prompt = (
        'Detect the language of this text. If Dutch (NL), translate to English. '
        'Respond ONLY as JSON with keys "lang" ("nl", "en", or "other") and "english" (translation or original).\n'
        f'Text: {message}'
    )
    try:
        from google.genai import types as _types
        resp = client.models.generate_content(
            model="gemini-2.0-flash-lite",
            contents=prompt,
            config=_types.GenerateContentConfig(response_mime_type="application/json"),
        )
        data = _json.loads(resp.text)
        return data.get("lang", "en"), data.get("english", message)
    except Exception as e:
        log.warning("pilot.lang_detect_failed", error=str(e))
        return "en", message
```

### run_pilot() with language detection injected
```python
def run_pilot(message, history, current_filters, email=None, db=None, app_state=None) -> dict:
    client = _get_client()

    # Dutch language detection + query translation
    detected_lang, search_message = _detect_and_translate(message, client)
    log.info("pilot.lang_detected", lang=detected_lang, original_len=len(message))

    # Base system instruction (existing)
    system_instruction = "..."  # existing string

    # Inject Dutch response instruction when user writes in Dutch
    if detected_lang == "nl":
        system_instruction += (
            "\n\nIMPORTANT: The user is writing in Dutch. Respond in Dutch. "
            "Keep expert names, job titles, and company names in English."
        )

    # Use search_message (English) for all search operations, message (original) for display
    # In _handle_search_experts: pass search_message as args["query"] override to run_explore()
    ...
```

### GapsTable NULL best_score display (TypeScript)
```typescript
// In GapsTable.tsx — best_score column cell render
const displayScore = (score: number | null) =>
  score != null ? score.toFixed(3) : '—'
```

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| NULL excluded from gaps | NULL included as gap | Phase 34.1 | All zero-candidate searches now visible in admin |
| English-only Sage | Auto-detects Dutch, responds in Dutch | Phase 34.1 | Dutch users get native-language experience |

**Note on Gemini model naming:** The codebase uses `gemini-2.5-flash` as `GENERATION_MODEL`. As of early 2026 the Gemini model lineup has evolved — verify available model IDs via the Gemini API if `gemini-2.0-flash-lite` is not available; a fallback to `gemini-2.0-flash` works fine.

---

## Open Questions

1. **Which Gemini model to use for language detection?**
   - What we know: `gemini-2.5-flash` is the current main model; `gemini-2.0-flash-lite` should be available as a cheaper/faster option
   - What's unclear: exact model ID availability on the Railway backend's Gemini API key
   - Recommendation: Try `gemini-2.0-flash-lite` first; fallback gracefully to `"en"` on any error (already handled in the proposed implementation)

2. **Does detecting language on every Sage message hurt latency noticeably?**
   - What we know: the detection call is a small JSON response; fast models handle this in ~200-400ms
   - What's unclear: actual p95 latency impact in Railway's environment
   - Recommendation: Accept the tradeoff since Dutch support is a product requirement; the detection is lightweight and fails safe

3. **Should history Dutch messages be re-translated for context?**
   - What we know: history is passed verbatim to Gemini; Gemini understands Dutch in history
   - Recommendation: No — Gemini handles multilingual history naturally; the Dutch system prompt instruction covers continuity

---

## Sources

### Primary (HIGH confidence)
- Codebase inspection of `app/routers/admin.py` (all 8 gap query locations identified by direct read)
- Codebase inspection of `app/services/pilot_service.py` (two-turn pattern, existing Gemini client)
- Codebase inspection of `app/routers/chat.py` (NULL score storage for zero-candidate results confirmed)
- SQLAlchemy 2.0 documentation — `.is_(None)` and `.is_not(None)` for NULL-safe ORM queries
- SQL standard behavior: `NULL < value` evaluates to NULL (not false, not true)

### Secondary (MEDIUM confidence)
- `google-genai` SDK `response_mime_type="application/json"` for structured output (verified in existing codebase usage patterns; Gemini supports JSON mode)
- `gemini-2.0-flash-lite` as a fast/cheap Gemini model variant (based on Gemini model lineup knowledge)

---

## Metadata

**Confidence breakdown:**
- Gap detection fix: HIGH — all locations identified by direct code read; SQL NULL semantics are well-understood
- Dutch Sage architecture: HIGH — uses existing Gemini client, no new deps, injection point is clear
- Gemini model choice for detection: MEDIUM — model name may need verification against live API

**Research date:** 2026-02-23
**Valid until:** 2026-03-23 (stable domain; Gemini model naming is the only volatile element)
