---
phase: 34.1-fix-zero-result-searches-missing-from-admin-gap-and-enable-the-sage-in-dutch
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/pilot_service.py
autonomous: true
requirements:
  - DUTCH-SAGE

must_haves:
  truths:
    - "When a user writes in Dutch to Sage, Sage responds in Dutch"
    - "Dutch queries are translated to English before FAISS search so expert matching uses English text"
    - "Expert names, job titles, and company names appear in English within the Dutch response"
    - "English queries continue to work exactly as before with no latency regression"
    - "If language detection fails, the system falls back to English behavior silently"
  artifacts:
    - path: "app/services/pilot_service.py"
      provides: "_detect_and_translate helper + Dutch system prompt injection in run_pilot"
      contains: "_detect_and_translate"
  key_links:
    - from: "app/services/pilot_service.py::run_pilot"
      to: "_detect_and_translate"
      via: "Called at top of run_pilot before any search/filter logic"
      pattern: "_detect_and_translate\\(message"
    - from: "app/services/pilot_service.py::run_pilot"
      to: "system_instruction"
      via: "Dutch instruction appended when detected_lang == 'nl'"
      pattern: "detected_lang.*==.*nl"
    - from: "app/services/pilot_service.py::_handle_search_experts"
      to: "run_explore"
      via: "English-translated query passed to FAISS search"
      pattern: "search_message|translated"
---

<objective>
Enable the Sage co-pilot to auto-detect Dutch user input, translate it to English for FAISS search, and respond in Dutch while keeping expert data in English.

Purpose: Dutch-speaking users should be able to interact with Sage in their native language. The FAISS index contains English expert bios, so queries must be translated before embedding search. Sage's narrative response should be in Dutch, but expert names/titles/rates remain as-is (they're data, not translatable content).

Output: `pilot_service.py` gains `_detect_and_translate()` helper and Dutch-aware `run_pilot()` flow.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34.1-fix-zero-result-searches-missing-from-admin-gap-and-enable-the-sage-in-dutch/34.1-RESEARCH.md
@app/services/pilot_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add _detect_and_translate helper using Gemini flash-lite</name>
  <files>app/services/pilot_service.py</files>
  <action>
Add a `_detect_and_translate()` function to `pilot_service.py` (place it after `_get_client()` and before the handler functions). This function uses the already-wired Gemini client to detect language and translate Dutch to English in a single structured JSON call.

Implementation:
```python
import json as _json

def _detect_and_translate(message: str, client: genai.Client) -> tuple[str, str]:
    """Detect language; if Dutch, translate to English for FAISS search.

    Returns (detected_lang, english_message):
      - detected_lang: 'nl', 'en', or 'other'
      - english_message: English translation (or original if already English)

    Uses gemini-2.0-flash-lite for speed — this is a structured JSON extraction,
    not a complex reasoning task. Falls back to ('en', original) on any error.
    """
    prompt = (
        'Detect the language of this text. If Dutch (NL), translate to English. '
        'Respond ONLY as JSON: {"lang": "nl"|"en"|"other", "english": "<translation or original>"}.\n'
        f'Text: {message}'
    )
    try:
        resp = client.models.generate_content(
            model="gemini-2.0-flash-lite",
            contents=prompt,
            config=types.GenerateContentConfig(
                response_mime_type="application/json",
            ),
        )
        data = _json.loads(resp.text)
        lang = data.get("lang", "en")
        english = data.get("english", message)
        log.info("pilot.lang_detected", lang=lang, original_len=len(message))
        return lang, english
    except Exception as e:
        log.warning("pilot.lang_detect_failed", error=str(e))
        return "en", message
```

Add `import json as _json` at the top of the file alongside the existing imports (check if `json` is already imported — it may be imported in _handle_search_experts via a local import; add it at module level instead).

**Model choice:** Use `gemini-2.0-flash-lite` for the detection call. If this model ID is not available (API error), the try/except falls back to English silently. Do NOT use `gemini-2.5-flash` (GENERATION_MODEL) for detection — it's unnecessarily heavy and adds 500-1500ms latency.
  </action>
  <verify>
    <automated>cd /Users/sebastianhamers/Documents/TCS && python -c "
import ast
source = open('app/services/pilot_service.py').read()
tree = ast.parse(source)
func_names = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]
assert '_detect_and_translate' in func_names, 'FAIL: _detect_and_translate not found'
assert 'gemini-2.0-flash-lite' in source, 'FAIL: should use flash-lite model'
assert 'response_mime_type' in source, 'FAIL: should use structured JSON response'
assert 'pilot.lang_detect' in source, 'FAIL: should log language detection'
print('PASS: _detect_and_translate helper exists with correct model and logging')
"
    </automated>
  </verify>
  <done>_detect_and_translate() helper exists in pilot_service.py, uses gemini-2.0-flash-lite, returns structured (lang, english_text) tuple, logs detection result, and falls back safely on error.</done>
</task>

<task type="auto">
  <name>Task 2: Wire language detection into run_pilot and pass translated query to search</name>
  <files>app/services/pilot_service.py</files>
  <action>
Modify `run_pilot()` to call `_detect_and_translate()` at the top and use the result throughout:

**Step 1 — Call detection at the top of run_pilot(), right after `client = _get_client()`:**
```python
client = _get_client()

# Dutch language detection + query translation
detected_lang, search_message = _detect_and_translate(message, client)
```

**Step 2 — Inject Dutch instruction into system_instruction when Dutch is detected:**
After the existing `system_instruction = (...)` string assignment (around line 295-318), add:
```python
if detected_lang == "nl":
    system_instruction += (
        "\n\nIMPORTANT: The user is writing in Dutch. You MUST respond entirely in Dutch. "
        "Expert names, job titles, and company names are proper nouns — keep them in English. "
        "All your narrative, explanation, and conversational text must be in Dutch."
    )
```

**Step 3 — Use the English translation for search queries:**
The user's original `message` continues to be added to `contents` (the conversation history) — Gemini sees what the user actually wrote. But the search query passed to `_handle_search_experts` must use the English translation.

Modify the `_handle_search_experts` call to pass `search_message` as an additional parameter. Update `_handle_search_experts` signature to accept `search_message: str | None = None`. Inside `_handle_search_experts`, when calling `run_explore()`, use `search_message if search_message else args.get("query", "")` for the query parameter.

Alternatively (simpler approach): Before the Turn 1 Gemini call, if `detected_lang == "nl"`, override `args["query"]` with `search_message` in the search_experts handler. The cleanest way is to pass `search_message` through:

In `run_pilot()`, change the `_handle_search_experts` call to:
```python
return _handle_search_experts(fn_call, args, response, contents, config, db, app_state, client, email=email, search_message=search_message)
```

In `_handle_search_experts`, add `search_message: str | None = None` parameter and use it:
```python
query = search_message if search_message else args.get("query", "")
result = run_explore(query=query, ...)
```

**Important:** The `apply_filters` path does NOT need translation — it only handles rate/tag adjustments, not free-text queries. Only `search_experts` uses a text query for FAISS search.

**Important:** Only the CURRENT message needs detection/translation. History messages are passed verbatim to Gemini in the contents array. Gemini handles multilingual context naturally; the Dutch system prompt instruction ensures response language continuity.

**Important:** The `message` (original Dutch) is still appended to `contents` for Turn 1 — Gemini must see the actual user message. The translated `search_message` is only used for the `run_explore()` FAISS call inside `_handle_search_experts`.
  </action>
  <verify>
    <automated>cd /Users/sebastianhamers/Documents/TCS && python -c "
import ast
source = open('app/services/pilot_service.py').read()
tree = ast.parse(source)
# Check run_pilot calls _detect_and_translate
assert '_detect_and_translate(message' in source, 'FAIL: run_pilot must call _detect_and_translate'
# Check Dutch system prompt injection
assert 'detected_lang ==' in source or 'detected_lang ==' in source, 'FAIL: must check detected_lang'
assert 'Dutch' in source, 'FAIL: Dutch instruction must be in system prompt'
# Check search_message is passed to handler
assert 'search_message' in source, 'FAIL: search_message must be passed through'
# Check the file still parses
ast.parse(source)
print('PASS: run_pilot wired with language detection, Dutch prompt, and search_message passthrough')
"
    </automated>
    <manual>Deploy to Railway. Send "vind me een fintech expert" to Sage. Verify: (1) Sage responds in Dutch, (2) expert grid shows relevant fintech experts (English bios matched correctly), (3) expert names/titles in Sage's response are in English.</manual>
  </verify>
  <done>run_pilot() detects Dutch at the top, injects Dutch system prompt, and passes the English-translated query to _handle_search_experts for FAISS search. English queries work exactly as before. apply_filters path is unaffected.</done>
</task>

</tasks>

<verification>
1. `python -c "import app.services.pilot_service"` succeeds (no import errors)
2. `_detect_and_translate` function exists and uses `gemini-2.0-flash-lite`
3. `run_pilot` calls `_detect_and_translate` at the top
4. Dutch system prompt instruction appended when `detected_lang == "nl"`
5. English-translated query used for FAISS search in `_handle_search_experts`
6. After deploy: Dutch message "vind me een expert in cybersecurity" returns Dutch Sage response with English expert data
7. After deploy: English messages work identically to before (no latency regression beyond ~200-400ms detection call)
</verification>

<success_criteria>
- _detect_and_translate helper exists with flash-lite model and safe fallback
- run_pilot integrates language detection before any search/filter logic
- Dutch-detected messages get Dutch system prompt injection
- FAISS search uses English translation of Dutch queries
- apply_filters path is unaffected by language detection
- Error in detection silently falls back to English
- No new dependencies added (uses existing google-genai client)
</success_criteria>

<output>
After completion, create `.planning/phases/34.1-fix-zero-result-searches-missing-from-admin-gap-and-enable-the-sage-in-dutch/34.1-02-SUMMARY.md`
</output>
