---
phase: 28-sage-search-engine
plan: 02
type: execute
wave: 2
depends_on:
  - 28-01
files_modified:
  - frontend/src/hooks/useSage.ts
  - frontend/src/store/pilotSlice.ts
autonomous: true
requirements:
  - SAGE-02
  - SAGE-03
  - SAGE-04

must_haves:
  truths:
    - "User asks Sage 'find me fintech experts' and the main expert grid updates to show matching experts without the user touching any filter"
    - "Sage responds with a natural-language message in the panel after every search (grid never updates silently)"
    - "Sage's search filters are reflected in the filter UI (chips, sliders, tags show Sage's applied values)"
    - "When Sage returns zero results, the grid stays unchanged and the panel shows an acknowledgment with a specific fallback suggestion"
    - "When Sage finds zero results and fallback also finds zero, the grid resets to show all experts"
    - "apply_filters path continues to work exactly as before (refinement queries layer filters on top)"
  artifacts:
    - path: "frontend/src/hooks/useSage.ts"
      provides: "search_performed branch dispatching validateAndApplyFilters with reset + Sage params"
      contains: "search_performed"
    - path: "frontend/src/store/pilotSlice.ts"
      provides: "Updated PilotMessage or PilotResponse type with search_performed, total fields"
      contains: "search_performed"
  key_links:
    - from: "frontend/src/hooks/useSage.ts"
      to: "frontend/src/store/filterSlice.ts"
      via: "validateAndApplyFilters() dispatches filter state"
      pattern: "validateAndApplyFilters"
    - from: "frontend/src/store/filterSlice.ts"
      to: "frontend/src/hooks/useExplore.ts"
      via: "reactive re-fetch on filter state change"
      pattern: "useExplore.*filter"
---

<objective>
Update `useSage.ts` to handle the new `search_performed` field from the pilot API. When Sage performs a search, clear all filters and apply Sage's search params via `validateAndApplyFilters()`, triggering `useExplore` to re-fetch the grid. Handle zero-result and double-zero-result cases. Update `pilotSlice.ts` types.

Purpose: This is the frontend half of Sage's search capability. Without it, the API response exists but the grid never updates and the UI doesn't distinguish search from filter refinement.
Output: Updated `useSage.ts` with dual-path dispatch logic; updated `pilotSlice.ts` with extended response types; full Sage search flow working end-to-end.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-sage-search-engine/28-CONTEXT.md
@.planning/phases/28-sage-search-engine/28-RESEARCH.md
@.planning/phases/28-sage-search-engine/28-01-SUMMARY.md
@frontend/src/hooks/useSage.ts
@frontend/src/store/pilotSlice.ts
@frontend/src/store/filterSlice.ts
@frontend/src/hooks/useExplore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update pilotSlice types for search_performed response fields</name>
  <files>frontend/src/store/pilotSlice.ts</files>
  <action>
In `frontend/src/store/pilotSlice.ts`, update the TypeScript type that represents the API response from `/api/pilot` (likely `PilotResponse` or the inline type in `useSage.ts` — check where the type is defined before editing).

Add the following fields to the pilot API response type:
```typescript
search_performed?: boolean   // true when search_experts was called
total?: number               // result count from search_experts
```

The `filters` field remains `Record<string, unknown> | null`.
The `message` field remains `string`.

If `PilotResponse` is defined in `pilotSlice.ts`, add the fields there. If it is defined inline in `useSage.ts`, add them in `useSage.ts` instead.

Do NOT add an `experts` field to `PilotMessage` — the locked decision requires text-only display in the Sage panel. Expert names appear inline in the narration string, not as structured data rendered as cards.

No store state changes are required — only the API response interface shape.
  </action>
  <verify>
Run `cd /Users/sebastianhamers/Documents/TCS/frontend && npx tsc --noEmit 2>&1 | head -20` — must produce no TypeScript errors related to pilotSlice.ts or PilotResponse type.
  </verify>
  <done>TypeScript type for pilot API response includes search_performed and total fields; tsc compiles without errors on these files.</done>
</task>

<task type="auto">
  <name>Task 2: Update useSage.ts with dual-path dispatch and zero-result handling</name>
  <files>frontend/src/hooks/useSage.ts</files>
  <action>
In `frontend/src/hooks/useSage.ts`, update the `handleSend()` function (or equivalent) to branch on `data.search_performed` after receiving the API response.

**The branching logic (replace the existing single `validateAndApplyFilters` call):**
```typescript
if (data.search_performed === true && data.filters && typeof data.filters === 'object') {
  // search_experts path: full replace — Sage takes full control of filter state
  // Clear all current filters first, then apply Sage's search params
  validateAndApplyFilters({ reset: true })
  validateAndApplyFilters(data.filters as Record<string, unknown>)
} else if (data.search_performed === true && !data.filters) {
  // search_experts returned zero results — check if it's a full reset signal
  // data.filters is null: grid stays as-is (zero results, fallback suggested in narration)
  // data.filters is {reset: true}: reset grid to all experts (double-zero fallback)
  // NOTE: backend sends filters: {reset: true} for double-zero case
  // For null filters: do nothing to the grid
} else if (data.filters && typeof data.filters === 'object') {
  // apply_filters path: layer on top of existing filter state
  validateAndApplyFilters(data.filters as Record<string, unknown>)
}
```

Wait — the backend sends `filters: {"reset": true}` for the double-zero case and `filters: null` for the zero-result-with-fallback case. The frontend must handle `{"reset": true}` specifically:

```typescript
if (data.search_performed === true) {
  if (data.filters && typeof data.filters === 'object') {
    const filtersObj = data.filters as Record<string, unknown>
    if (filtersObj.reset === true) {
      // Double-zero: reset grid to show all experts
      validateAndApplyFilters({ reset: true })
    } else {
      // Search found results: clear slate, apply Sage's search params
      validateAndApplyFilters({ reset: true })
      validateAndApplyFilters(filtersObj)
    }
  }
  // If data.filters is null: grid stays as-is (zero results, Sage narrates alternative)
} else if (data.filters && typeof data.filters === 'object') {
  // apply_filters refinement path — unchanged behavior
  validateAndApplyFilters(data.filters as Record<string, unknown>)
}
```

**Then add the assistant message to the pilot slice (after the branch):**
```typescript
addMessage({
  id: `${Date.now()}-assistant`,
  role: 'assistant',
  content: data.message ?? "I've updated your search. Check the results!",
  timestamp: Date.now(),
})
```

Ensure the existing error handling and loading state management are preserved around this change.

**CRITICAL rules (from research):**
- NEVER call `store.setResults()` or any `resultsSlice` setter from `useSage` — `validateAndApplyFilters()` dispatches to `filterSlice` which triggers `useExplore` reactive re-fetch. That IS the grid update.
- `validateAndApplyFilters({ reset: true })` already exists in the codebase — use it exactly as found.
- The `search_performed` check must come BEFORE the `data.filters` truthy check to avoid misrouting a zero-result search (where filters is null) into the apply_filters path.

**After the 20-query test (post-deploy):**
The executor (Claude running this plan) should note that a description-tuning iteration may be needed if Gemini misroutes boundary queries. The function descriptions added in Plan 28-01 are designed to be mutually exclusive, but empirical validation via Railway logs is required before declaring Phase 28 complete.

Add a brief comment in the code near the `search_performed` branch:
```typescript
// search_performed: true = search_experts was called; false/undefined = apply_filters
// NEVER write resultsSlice directly — validateAndApplyFilters triggers useExplore re-fetch
```
  </action>
  <verify>
1. Run `cd /Users/sebastianhamers/Documents/TCS/frontend && npx tsc --noEmit 2>&1 | head -30` — no TypeScript errors.
2. Run `cd /Users/sebastianhamers/Documents/TCS/frontend && npm run build 2>&1 | tail -10` — build exits 0.
3. Check: `grep -n "setResults" /Users/sebastianhamers/Documents/TCS/frontend/src/hooks/useSage.ts` — must return NO matches (confirm resultsSlice is never written by useSage).
4. Check: `grep -n "validateAndApplyFilters" /Users/sebastianhamers/Documents/TCS/frontend/src/hooks/useSage.ts` — must show at least 2 occurrences (the reset call + the params call).
  </verify>
  <done>
- useSage.ts branches on search_performed correctly
- search_experts path: calls validateAndApplyFilters({reset:true}) then validateAndApplyFilters(data.filters) for results; does nothing for zero-result; calls validateAndApplyFilters({reset:true}) for double-zero
- apply_filters path unchanged
- No setResults() call anywhere in useSage.ts
- Frontend build passes (tsc + vite build exit 0)
  </done>
</task>

<task type="auto">
  <name>Task 3: End-to-end verification and 20-query routing test</name>
  <files>app/services/pilot_service.py</files>
  <action>
Deploy the changes and run the 20-query routing test from the `conversations` table. This task verifies that Gemini correctly routes between `search_experts` and `apply_filters` across real production queries.

**Step 1 — Deploy:**
Push to main branch. Both Railway (backend) and Vercel (frontend) deploy automatically on `git push`. Wait for Railway deploy to complete (check https://railway.app/dashboard — look for green deploy status).

**Step 2 — Extract real queries from DB:**
In Railway's shell or via the admin endpoint, run:
```sql
SELECT DISTINCT query FROM conversations ORDER BY created_at DESC LIMIT 20;
```
Or read from the Railway logs after sending test requests.

**Step 3 — Run 20 test queries via the API:**
Send POST requests to `https://web-production-fdbf9.up.railway.app/api/pilot` with each query as the message. Use a simple Python or curl loop:

```bash
curl -s -X POST https://web-production-fdbf9.up.railway.app/api/pilot \
  -H "Content-Type: application/json" \
  -d '{"message": "find me fintech experts", "history": [], "current_filters": {}}' \
  | python3 -m json.tool
```

**Step 4 — Assert fn_call.name in Railway logs:**
For each request, check Railway logs for the structured log line:
```
pilot: search_experts executed  fn_name=search_experts  total=N  query=...
```
OR (for apply_filters):
```
pilot: request processed  fn_name=apply_filters  ...
```

**Expected routing (classify each query before testing):**
- Discovery queries → `search_experts`: "find me X", "I need someone who", "who can help with", "show me Z experts", "looking for an expert in"
- Refinement queries → `apply_filters`: "narrow to $150/hr", "only show blockchain", "filter by rate", "under $200"

**Step 5 — If routing accuracy < 90%:**
Tune the function descriptions in `pilot_service.py`. The primary lever is making the `apply_filters` description explicitly say "do NOT use this when the user wants to find experts — only for adjusting what they see." Re-deploy and re-test.

This is a pilot_service.py edit if tuning is needed — hence the file is listed. If routing accuracy is acceptable (18/20+ correct), no code change is needed and this task is complete after logging the test results.

Log the test results as a comment in the `_handle_search_experts()` function header or in the SUMMARY.md.
  </action>
  <verify>
Railway logs show `fn_call.name` field in at least 20 pilot requests. At least 18 of 20 queries route to the expected function (search_experts for discovery queries, apply_filters for refinement queries). If under 18/20, one description-tuning iteration is performed and the test is re-run.
  </verify>
  <done>20 real queries tested; at least 18/20 route correctly; fn_call.name appears in all Railway log entries; routing accuracy confirmed or description tuned until confirmed.</done>
</task>

</tasks>

<verification>
1. `cd /Users/sebastianhamers/Documents/TCS/frontend && npm run build` exits 0
2. `grep "setResults" frontend/src/hooks/useSage.ts` returns no matches
3. `grep "search_performed" frontend/src/hooks/useSage.ts` shows the branch
4. POST /api/pilot with "find me fintech experts" returns `{"search_performed": true, "message": "...", "filters": {...}}`
5. POST /api/pilot with "narrow to under $200" returns `{"search_performed": false, "filters": {...}}`
6. Railway logs show `fn_call.name` in structured log for every pilot request
</verification>

<success_criteria>
- User asks discovery query → grid updates with matching experts + Sage narrates result count and names
- User asks refinement query → existing apply_filters path works unchanged
- Zero results → grid unchanged + Sage suggests specific closest match
- Double-zero results → grid resets to all experts + Sage states no match found
- Frontend build passes with no TypeScript errors
- 18+/20 real queries route to correct function in Railway logs
</success_criteria>

<output>
After completion, create `.planning/phases/28-sage-search-engine/28-02-SUMMARY.md`
</output>
