---
phase: 26-embedding-heatmap
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - requirements.txt
  - app/main.py
  - app/routers/admin.py
autonomous: true
requirements:
  - INTEL-05

must_haves:
  truths:
    - "Railway healthcheck passes within 10 seconds of deployment (t-SNE computation does not block the lifespan yield)"
    - "GET /api/admin/embedding-map returns HTTP 202 with {status: computing} while t-SNE is running"
    - "GET /api/admin/embedding-map returns HTTP 200 with {status: ready, points: [...], count: N} when computation is complete"
    - "Each point in the response has x, y, name, category, and username fields"
    - "app.state.embedding_map is populated and app.state.tsne_ready is True within 30 seconds of startup"
  artifacts:
    - path: "requirements.txt"
      provides: "scikit-learn and scipy pinned dependencies"
      contains: "scikit-learn==1.8.0"
    - path: "app/main.py"
      provides: "_compute_tsne_background coroutine + post-yield create_task"
      exports: ["_compute_tsne_background"]
    - path: "app/routers/admin.py"
      provides: "GET /embedding-map endpoint with 202 guard"
      contains: "embedding-map"
  key_links:
    - from: "app/main.py lifespan"
      to: "_compute_tsne_background"
      via: "asyncio.create_task called immediately after yield"
      pattern: "create_task.*_compute_tsne_background"
    - from: "_compute_tsne_background"
      to: "app.state.embedding_map"
      via: "asyncio.to_thread wrapping sklearn PCA + TSNE"
      pattern: "app\\.state\\.embedding_map = result"
    - from: "app/routers/admin.py"
      to: "app.state.tsne_ready"
      via: "getattr guard returning 202 if not ready"
      pattern: "tsne_ready"
---

<objective>
Add the backend infrastructure for the embedding heatmap: scikit-learn/scipy dependencies, a non-blocking background t-SNE computation task launched post-lifespan-yield, and the `/api/admin/embedding-map` endpoint with a 202 guard.

Purpose: Expose 530 expert embeddings as a 2D t-SNE projection for the admin scatter plot without blocking Railway's healthcheck.
Output: requirements.txt with scikit-learn + scipy, main.py with `_compute_tsne_background` + post-yield `asyncio.create_task`, admin.py with `GET /embedding-map`.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-embedding-heatmap/26-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add scikit-learn and scipy to requirements.txt + initialize app.state flags in lifespan</name>
  <files>requirements.txt, app/main.py</files>
  <action>
    **requirements.txt** — Add two new lines after the `numpy==2.2.*` line:
    ```
    scikit-learn==1.8.0
    scipy==1.15.1
    ```

    **app/main.py** — Two surgical changes to the lifespan function:

    1. Before the `yield` (after the `app.state.tsne_cache = []` line at line 221), add two new state initializations:
    ```python
    app.state.tsne_ready = False    # Phase 26: False until background task completes
    app.state.embedding_map = []    # Phase 26: populated by _compute_tsne_background
    ```

    2. After the `yield` line (currently: `yield\n    # Shutdown: ...`), add the background task launch:
    ```python
    yield
    asyncio.create_task(_compute_tsne_background(app))  # Phase 26: post-yield — NEVER above yield
    # Shutdown: in-memory FAISS index is garbage-collected automatically
    ```

    Also add `import asyncio` and `import numpy as np` to main.py imports if not already present.
    (Check: `asyncio` is used in asynccontextmanager but may not be explicitly imported — add it to the top-level imports block. `numpy` is not currently imported in main.py — add `import numpy as np`.)

    **CRITICAL:** `asyncio.create_task` MUST be placed after the `yield` line, not before. Placing it before blocks Railway's healthcheck and causes an infinite restart loop.
  </action>
  <verify>
    Run `python -c "import ast; ast.parse(open('app/main.py').read()); print('syntax ok')"` from the project root to confirm no syntax errors.
    Visually confirm `asyncio.create_task(_compute_tsne_background(app))` appears after the `yield` line in the lifespan function.
    Confirm `requirements.txt` contains `scikit-learn==1.8.0` and `scipy==1.15.1`.
  </verify>
  <done>
    requirements.txt has scikit-learn==1.8.0 and scipy==1.15.1.
    app/main.py lifespan sets app.state.tsne_ready = False and app.state.embedding_map = [] before yield.
    asyncio.create_task(_compute_tsne_background(app)) is the first statement after yield in the lifespan.
    File passes Python syntax check.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add _compute_tsne_background coroutine to main.py + GET /embedding-map endpoint to admin.py</name>
  <files>app/main.py, app/routers/admin.py</files>
  <action>
    **app/main.py** — Add the `_compute_tsne_background` coroutine as a module-level function, placed before the `lifespan` function definition. Use the exact implementation from the research file:

    ```python
    async def _compute_tsne_background(app: FastAPI) -> None:
        """
        Compute t-SNE projection of FAISS embeddings in a background thread.
        Called via asyncio.create_task after lifespan yield — NEVER before yield.
        Sets app.state.tsne_ready = True on completion (or on failure, to stop 202 responses).
        """
        try:
            log.info("tsne.background_task_started")
            index = app.state.faiss_index
            metadata = app.state.metadata
            n = index.ntotal

            if n == 0:
                log.warning("tsne.no_vectors")
                app.state.embedding_map = []
                app.state.tsne_ready = True
                return

            def _run() -> list:
                from sklearn.decomposition import PCA
                from sklearn.manifold import TSNE

                # Extract raw vectors from FAISS index (reconstruct(i) works on all flat index types)
                vectors = np.zeros((n, index.d), dtype=np.float32)
                for i in range(n):
                    vectors[i] = index.reconstruct(i)

                # Normalize for cosine metric (safe no-op if already unit-normalized)
                norms = np.linalg.norm(vectors, axis=1, keepdims=True)
                norms[norms == 0] = 1.0
                vectors = vectors / norms

                # PCA pre-reduction (mandatory — cuts compute 4-8x vs. direct t-SNE on 768-dim)
                n_components = min(50, n - 1, vectors.shape[1])
                pca = PCA(n_components=n_components)
                reduced = pca.fit_transform(vectors)

                # t-SNE projection — use max_iter NOT n_iter (n_iter removed in sklearn 1.7)
                perplexity = min(30, n - 1)
                tsne = TSNE(
                    perplexity=perplexity,
                    max_iter=1000,
                    init='pca',
                    random_state=42,
                    metric='cosine',
                )
                coords = tsne.fit_transform(reduced)  # shape (n, 2)

                # Build result list aligned with metadata order
                points = []
                for i, row in enumerate(metadata):
                    points.append({
                        "x": float(coords[i, 0]),
                        "y": float(coords[i, 1]),
                        "name": f"{row.get('First Name', '')} {row.get('Last Name', '')}".strip(),
                        "category": row.get("category") or "Unknown",
                        "username": row.get("Username", ""),
                    })
                return points

            result = await asyncio.to_thread(_run)
            # Set embedding_map BEFORE tsne_ready to avoid serving empty results
            app.state.embedding_map = result
            app.state.tsne_ready = True
            log.info("tsne.complete", points=len(result))

        except Exception as exc:
            log.error("tsne.failed", error=str(exc))
            app.state.embedding_map = []
            app.state.tsne_ready = True  # Mark ready even on failure so 202 stops being returned

    ```

    **app/routers/admin.py** — Add the embedding-map endpoint to the authenticated `router` (the one with `_require_admin` dependency — NOT the `auth_router`). Place it after the existing intelligence endpoint. Ensure `JSONResponse` is imported (check if already imported; if not, add `from fastapi.responses import JSONResponse` to the imports block):

    ```python
    @router.get("/embedding-map")
    def get_embedding_map(request: Request):
        """
        Return t-SNE 2D projection of all expert embeddings.
        Returns HTTP 202 with {status: computing} while background task runs (up to ~30s post-startup).
        Returns HTTP 200 with {status: ready, points: [...], count: N} when ready.
        Each point: {x: float, y: float, name: str, category: str, username: str}
        """
        if not getattr(request.app.state, "tsne_ready", False):
            return JSONResponse({"status": "computing"}, status_code=202)
        return {
            "status": "ready",
            "points": request.app.state.embedding_map,
            "count": len(request.app.state.embedding_map),
        }
    ```

    Check admin.py imports to see if `Request` is already imported from fastapi — it is used elsewhere, but confirm. If `JSONResponse` is not imported, add it to the fastapi.responses import.
  </action>
  <verify>
    Run `python -c "import ast; ast.parse(open('app/main.py').read()); print('syntax ok')"` and `python -c "import ast; ast.parse(open('app/routers/admin.py').read()); print('syntax ok')"` from project root.
    Grep for `_compute_tsne_background` in main.py — should appear twice (definition + create_task call).
    Grep for `embedding-map` in admin.py — should appear in the route decorator.
  </verify>
  <done>
    app/main.py contains `_compute_tsne_background` coroutine as a module-level function before lifespan.
    app/routers/admin.py has GET /embedding-map endpoint returning 202 when not ready, 200 with points when ready.
    Both files pass Python syntax checks.
    `app.state.embedding_map = result` is set before `app.state.tsne_ready = True` in the coroutine.
  </done>
</task>

</tasks>

<verification>
From project root:
1. `python -c "import ast; ast.parse(open('app/main.py').read()); print('ok')"` — no syntax errors
2. `python -c "import ast; ast.parse(open('app/routers/admin.py').read()); print('ok')"` — no syntax errors
3. `grep -n "create_task" app/main.py` — shows create_task AFTER yield line
4. `grep -n "tsne_ready\|embedding_map" app/main.py` — shows both state initializations before yield and assignment in coroutine
5. `grep "scikit-learn\|scipy" requirements.txt` — confirms both deps present
6. `grep -n "embedding-map" app/routers/admin.py` — confirms endpoint registered
</verification>

<success_criteria>
- requirements.txt contains scikit-learn==1.8.0 and scipy==1.15.1
- app/main.py: _compute_tsne_background defined before lifespan; asyncio.create_task fires post-yield; app.state.tsne_ready and app.state.embedding_map initialized before yield
- app/routers/admin.py: GET /embedding-map returns 202 while computing, 200 with points array when ready
- Both files pass Python syntax checks
- No t-SNE code runs before the yield (confirmed by grep)
</success_criteria>

<output>
After completion, create `.planning/phases/26-embedding-heatmap/26-01-SUMMARY.md`
</output>
