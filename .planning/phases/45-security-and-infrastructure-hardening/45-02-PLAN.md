---
phase: 45-security-and-infrastructure-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/database.py
  - app/main.py
autonomous: true
requirements: [SEC-03, ADM-03]

must_haves:
  truths:
    - "SQLite uses WAL journal mode — concurrent reads and writes do not produce 'database is locked' errors"
    - "Every new SQLite connection has busy_timeout=5000 set"
    - "The t-SNE background computation starts at server startup, not shutdown"
    - "The /api/admin/embedding-map endpoint returns 200 with data after t-SNE completes (not perpetual 202)"
  artifacts:
    - path: "app/database.py"
      provides: "SQLAlchemy connect event listener setting WAL + busy_timeout PRAGMAs"
      contains: "PRAGMA journal_mode=WAL"
    - path: "app/main.py"
      provides: "t-SNE create_task before yield in lifespan"
      contains: "create_task(_compute_tsne_background"
  key_links:
    - from: "app/database.py"
      to: "SQLite database file"
      via: "event.listens_for(engine, 'connect') callback"
      pattern: "listens_for.*engine.*connect"
    - from: "app/main.py lifespan"
      to: "_compute_tsne_background"
      via: "asyncio.create_task before yield"
      pattern: "create_task.*tsne.*\n.*yield"
---

<objective>
Enable SQLite WAL mode for concurrent traffic safety and fix the t-SNE background task placement so the embedding heatmap actually computes at startup.

Purpose: Prevent "database is locked" errors under public traffic load and fix the permanently-loading heatmap on the Intelligence admin page.
Output: WAL + busy_timeout PRAGMAs on every SQLite connection; t-SNE computation launched at startup instead of shutdown.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-security-and-infrastructure-hardening/45-CONTEXT.md
@.planning/phases/45-security-and-infrastructure-hardening/45-RESEARCH.md
@app/database.py
@app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: SQLite WAL mode via connect event and t-SNE lifespan fix</name>
  <files>
    app/database.py
    app/main.py
  </files>
  <action>
**1. Add WAL + busy_timeout PRAGMAs to app/database.py:**

Add an import for `event` from sqlalchemy, then register a connect event listener on the engine. Place this after the `engine = create_engine(...)` line:

```python
from sqlalchemy import create_engine, event

engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False},
)

@event.listens_for(engine, "connect")
def _set_sqlite_pragma(dbapi_connection, connection_record):
    """Enable WAL mode and set busy_timeout on every new connection.
    WAL persists at the file level once set, but busy_timeout is per-connection."""
    cursor = dbapi_connection.cursor()
    cursor.execute("PRAGMA journal_mode=WAL")
    cursor.execute("PRAGMA busy_timeout=5000")
    cursor.close()
```

This is idempotent — setting WAL on an already-WAL database is a no-op. The busy_timeout MUST be set per-connection because it does NOT persist at the file level (unlike journal_mode=WAL). 5000ms (5 seconds) gives concurrent writers time to complete before raising "database is locked".

**2. Fix t-SNE background task placement in app/main.py:**

In the `lifespan` async context manager, find the line:
```python
    yield
    asyncio.create_task(_compute_tsne_background(app))  # Phase 26: post-yield — NEVER above yield
```

Move `asyncio.create_task` to BEFORE `yield`. The current placement runs the task during shutdown (code after yield in an async context manager runs during the shutdown phase). The fix:

```python
    asyncio.create_task(_compute_tsne_background(app))  # Phase 26: launch at startup (before yield = startup, after yield = shutdown)
    yield
    # Shutdown: in-memory FAISS index is garbage-collected automatically
```

The old comment said "post-yield — NEVER above yield" but that was incorrect — code after yield in a lifespan context manager runs at SHUTDOWN, not at startup. The intent was for t-SNE to compute in the background while the server is running. Placing `create_task` before `yield` starts the coroutine, then `yield` hands control to the server. The t-SNE computation runs concurrently in the background while the server handles requests.

**Important:** Do NOT remove or change the `app.state.tsne_ready = False` and `app.state.embedding_map = []` lines that appear earlier in the lifespan. Those must remain set before the create_task call. The final order should be:
```python
    app.state.tsne_cache = []
    app.state.tsne_ready = False
    app.state.embedding_map = []
    # ... (any other state initialization)
    asyncio.create_task(_compute_tsne_background(app))
    yield
```
  </action>
  <verify>
    <automated>cd /Users/sebastianhamers/Documents/TCS && python -c "
from app.database import engine, _set_sqlite_pragma
from sqlalchemy import event, text
# Verify event listener is registered
listeners = event.contains(engine, 'connect', _set_sqlite_pragma)
assert listeners, 'WAL event listener not registered'
# Verify WAL is active
with engine.connect() as conn:
    mode = conn.execute(text('PRAGMA journal_mode')).scalar()
    assert mode == 'wal', f'Expected WAL, got {mode}'
    timeout = conn.execute(text('PRAGMA busy_timeout')).scalar()
    assert timeout == 5000, f'Expected 5000, got {timeout}'
print('WAL + busy_timeout OK')
" && python -c "
import ast, sys
with open('app/main.py') as f:
    source = f.read()
# Check that create_task is before yield
ct_pos = source.find('create_task(_compute_tsne_background')
yield_pos = source.find('yield', ct_pos) if ct_pos != -1 else -1
assert ct_pos != -1, 'create_task not found'
assert yield_pos != -1 and ct_pos < yield_pos, 'create_task must be before yield'
print('t-SNE placement OK')
"</automated>
    <manual>Start the server locally and check that /api/admin/embedding-map returns 200 with data after ~30 seconds (not perpetual 202)</manual>
  </verify>
  <done>
    - Every SQLite connection executes PRAGMA journal_mode=WAL and PRAGMA busy_timeout=5000
    - WAL mode confirmed active via PRAGMA query
    - asyncio.create_task(_compute_tsne_background(app)) appears before yield in lifespan
    - The old incorrect comment about "post-yield" is corrected
  </done>
</task>

</tasks>

<verification>
1. `python -c "from sqlalchemy import text; from app.database import engine; print(engine.connect().execute(text('PRAGMA journal_mode')).scalar())"` returns "wal"
2. `python -c "from sqlalchemy import text; from app.database import engine; print(engine.connect().execute(text('PRAGMA busy_timeout')).scalar())"` returns "5000"
3. Grep `app/main.py` for pattern: `create_task.*tsne` appears before the `yield` statement in the lifespan function
4. No `asyncio.create_task` calls remain after `yield` in the lifespan function
</verification>

<success_criteria>
- SQLite WAL mode is active on all connections with busy_timeout=5000
- t-SNE background task launches at startup (before yield), not at shutdown (after yield)
- The embedding-map endpoint can return 200 with actual data after server startup
</success_criteria>

<output>
After completion, create `.planning/phases/45-security-and-infrastructure-hardening/45-02-SUMMARY.md`
</output>
