---
phase: 32-sage-direct-search
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/store/resultsSlice.ts
  - frontend/src/store/filterSlice.ts
  - frontend/src/store/index.ts
  - frontend/src/hooks/useExplore.ts
  - frontend/src/hooks/useSage.ts
autonomous: true
requirements:
  - SAGE-DX-01
  - SAGE-DX-02
  - SAGE-DX-03

must_haves:
  truths:
    - "Sage discovery query injects experts into the grid without touching filterSlice (search bar stays empty)"
    - "useExplore does not re-fetch from /api/explore while sageMode is true"
    - "Any filter action (setQuery, setRateRange, toggleTag, setTags, resetFilters) sets sageMode=false and triggers a normal useExplore fetch"
    - "setSortBy does NOT exit sage mode (reordering Sage results is valid)"
    - "sageMode is not persisted to localStorage (resets to false on page refresh)"
    - "Zero-result Sage queries call setResults([], 0, null) + setSageMode(true), rendering the EmptyState"
  artifacts:
    - path: "frontend/src/store/resultsSlice.ts"
      provides: "sageMode boolean + setSageMode action"
      contains: "sageMode"
    - path: "frontend/src/store/filterSlice.ts"
      provides: "Cross-slice setSageMode(false) calls in filter actions"
      contains: "getSageMode"
    - path: "frontend/src/store/index.ts"
      provides: "sageMode + setSageMode exposed in useResultsSlice hook"
      contains: "setSageMode"
    - path: "frontend/src/hooks/useExplore.ts"
      provides: "sageMode guard — early return before fetch when sageMode=true"
      contains: "if (sageMode) return"
    - path: "frontend/src/hooks/useSage.ts"
      provides: "Direct store injection via setResults + setSageMode for search_performed=true path"
      contains: "setSageMode(true)"
  key_links:
    - from: "frontend/src/hooks/useSage.ts"
      to: "frontend/src/store/resultsSlice.ts"
      via: "store.setResults(experts, total, null) + store.setSageMode(true)"
      pattern: "setSageMode\\(true\\)"
    - from: "frontend/src/store/filterSlice.ts"
      to: "frontend/src/store/resultsSlice.ts"
      via: "get().setSageMode(false) in each filter action"
      pattern: "getSageMode|setSageMode\\(false\\)"
    - from: "frontend/src/hooks/useExplore.ts"
      to: "frontend/src/store/resultsSlice.ts"
      via: "sageMode selector + early-return guard"
      pattern: "sageMode"
---

<objective>
Wire Sage discovery results directly into the expert grid using a `sageMode` store flag, bypassing `useExplore`'s automatic re-fetch.

Purpose: When Sage runs `search_experts`, the current code calls `validateAndApplyFilters({ query: ... })` which pollutes the search bar with the Sage query text AND triggers a broad FTS5 re-fetch that discards the FAISS-ranked results. This plan replaces that with direct store injection: `useSage` calls `store.setResults(experts, total, null)` + `store.setSageMode(true)`, and `useExplore` early-returns when `sageMode` is true.

Output: Five files updated implementing the sageMode state machine. All three requirements SAGE-DX-01/02/03 addressed by the store architecture changes.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-sage-direct-search/32-CONTEXT.md
@.planning/phases/32-sage-direct-search/32-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sageMode to resultsSlice and expose in useResultsSlice</name>
  <files>
    frontend/src/store/resultsSlice.ts
    frontend/src/store/index.ts
  </files>
  <action>
**In `resultsSlice.ts`:**

Add `sageMode` and `setSageMode` to the `ResultsSlice` interface:
```typescript
export interface ResultsSlice {
  // ... existing fields ...
  sageMode: boolean
  setSageMode: (v: boolean) => void
}
```

Add initial state and action in `createResultsSlice`:
```typescript
sageMode: false,
setSageMode: (v) => set({ sageMode: v }),
```

Update `resetResults` to clear `sageMode`:
```typescript
resetResults: () =>
  set({ experts: [], total: 0, cursor: null, loading: false, error: null, sageMode: false }),
```

NOTE: Do NOT add `sageMode` to the `partialize` list in `index.ts` — the allowlist in index.ts only includes `query`, `rateMin`, `rateMax`, `tags`, `sortBy`, `sortOrder`. `sageMode` is automatically excluded because it's not on the allowlist. `sageMode` is ephemeral display state — it MUST reset to `false` on page refresh.

**In `index.ts`:**

Add `sageMode` and `setSageMode` to the `useResultsSlice` hook's `useShallow` selector:
```typescript
export const useResultsSlice = () =>
  useExplorerStore(
    useShallow((state) => ({
      // ... existing fields ...
      sageMode:       state.sageMode,
      setSageMode:    state.setSageMode,
    }))
  )
```

Do NOT modify `partialize` in `index.ts` — leave it exactly as it is.
  </action>
  <verify>
    TypeScript build passes: `cd frontend && npm run build` (no type errors).
    `grep -n "sageMode" frontend/src/store/resultsSlice.ts` shows sageMode in interface, initial state, setSageMode action, and resetResults.
    `grep -n "sageMode" frontend/src/store/index.ts` shows sageMode in useResultsSlice selector but NOT in partialize.
  </verify>
  <done>
    `ResultsSlice` interface has `sageMode: boolean` and `setSageMode: (v: boolean) => void`.
    `createResultsSlice` initializes `sageMode: false` and implements `setSageMode`.
    `resetResults` clears `sageMode: false`.
    `useResultsSlice` exposes `sageMode` and `setSageMode`.
    `partialize` in `index.ts` is unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add setSageMode(false) to filter actions + sageMode guard in useExplore + direct injection in useSage</name>
  <files>
    frontend/src/store/filterSlice.ts
    frontend/src/hooks/useExplore.ts
    frontend/src/hooks/useSage.ts
  </files>
  <action>
**In `filterSlice.ts`:**

Add `get` as the third argument to the `StateCreator` factory (currently only `set` is declared). Then call `get().setSageMode(false)` in each filter action that should exit sage mode:

```typescript
export const createFilterSlice: StateCreator<
  ExplorerStore,
  [['zustand/persist', unknown]],
  [],
  FilterSlice
> = (set, get) => ({    // <-- add `get` parameter
  ...filterDefaults,

  setQuery: (q) => {
    get().setSageMode(false)
    set({ query: q })
  },

  setRateRange: (min, max) => {
    get().setSageMode(false)
    set({ rateMin: min, rateMax: max })
  },

  toggleTag: (tag) => {
    get().setSageMode(false)
    set((state) => ({
      tags: state.tags.includes(tag)
        ? state.tags.filter((t) => t !== tag)
        : [...state.tags, tag],
    }))
  },

  setTags: (tags) => {
    get().setSageMode(false)
    set({ tags })
  },

  setSortBy: (sortBy) => set({ sortBy }),  // sort does NOT exit sage mode

  resetFilters: () => {
    get().setSageMode(false)
    set({ ...filterDefaults })
  },
})
```

`setSortBy` intentionally does NOT call `setSageMode(false)` — sorting is reordering Sage results, not requesting new filter-driven results.

The cross-slice `get().setSageMode` works because `get()` at runtime returns the full combined `ExplorerStore` which includes `setSageMode` from `resultsSlice`. This is the standard Zustand cross-slice pattern (confirmed as existing pattern in codebase via `useExplorerStore.getState()` in useSage.ts).

**In `useExplore.ts`:**

Add `sageMode` selector and early-return guard at the top of the `useEffect`:

After the existing selectors block, add:
```typescript
const sageMode = useExplorerStore((s) => s.sageMode)
```

In the `useEffect`, add the guard as the VERY FIRST statement before `controllerRef.current.abort()` or any `setLoading` call:
```typescript
useEffect(() => {
  // Sage mode guard — must come FIRST, before abort or setLoading to avoid loading flash
  if (sageMode) return

  // Abort any in-flight request from the previous effect run
  if (controllerRef.current) {
    controllerRef.current.abort()
  }
  // ... rest of existing fetch logic unchanged ...
}, [query, rateMin, rateMax, tags, sortBy, sageMode, setLoading, setResults, setError, resetResults])
//                                              ^^^^^-- ADD sageMode to dep array
```

`loadNextPage` does not need changes — in sage mode, `cursor=null` (because `setResults` is called with `null`), so `if (cursor === null ...) return` already prevents infinite scroll in sage mode.

**In `useSage.ts`:**

1. Import `Expert` type at the top (add to the store import):
```typescript
import { useExplorerStore } from '../store'
import type { Expert } from '../store/resultsSlice'
```

2. Extend the local `data` type annotation to include `experts`:
```typescript
const data: {
  filters: Record<string, unknown> | null
  message: string
  search_performed?: boolean
  total?: number
  experts?: Expert[]    // <-- ADD
} = await res.json()
```

3. Replace the `search_performed === true` handling block. Current broken code:
```typescript
if (data.search_performed === true) {
  if (data.filters && typeof data.filters === 'object') {
    const filtersObj = data.filters as Record<string, unknown>
    if (filtersObj.reset === true) {
      validateAndApplyFilters({ reset: true })
    } else {
      validateAndApplyFilters({ reset: true })
      validateAndApplyFilters(filtersObj)
    }
  }
  // If data.filters is null: grid stays as-is
}
```

New correct code:
```typescript
if (data.search_performed === true) {
  const store = useExplorerStore.getState()
  const experts = data.experts ?? []
  const total = data.total ?? 0
  store.setLoading(false)        // ensure loading=false before setResults (avoids skeleton flash if prior fetch was mid-flight)
  store.setResults(experts, total, null)
  store.setSageMode(true)
  // Note: apply_filters path (data.search_performed !== true) still uses
  // validateAndApplyFilters — that behavior is unchanged.
}
```

The `validateAndApplyFilters` function and the `else if (data.filters ...)` block for `apply_filters` remain completely unchanged. The tracking block (`void trackEvent(...)`) also remains unchanged — it fires before this branching logic.

IMPORTANT: `useExplorerStore.getState()` is the correct pattern for async handlers (already used in useSage.ts line 83: `const storeState = useExplorerStore.getState()`). This is NOT a hook call — it's a static store accessor, safe inside async callbacks.
  </action>
  <verify>
    TypeScript build: `cd /Users/sebastianhamers/Documents/TCS/frontend && npm run build` — zero errors.

    Behavioral verification (manual, in browser):
    1. Open the marketplace — search bar is empty, grid loads normally.
    2. Open Sage, ask "find me a fintech expert" — grid updates with Sage results, search bar stays empty.
    3. While in sage mode, type a letter in the search bar — grid switches to normal filter-driven results.
    4. Repeat sage query, then change the rate slider — grid switches to normal results.
    5. Repeat sage query, then click a tag chip — grid switches silently (no confirmation yet — that's Plan 03).
  </verify>
  <done>
    Sage discovery results appear in the grid without polluting the search bar.
    useExplore does not re-fetch while sageMode=true.
    setQuery/setRateRange/toggleTag/setTags/resetFilters all call setSageMode(false).
    setSortBy does not call setSageMode(false).
    Zero-result Sage queries show the EmptyState (setResults([], 0, null) + setSageMode(true)).
    TypeScript build passes with zero errors.
  </done>
</task>

</tasks>

<verification>
```
cd /Users/sebastianhamers/Documents/TCS/frontend && npm run build
```
Zero TypeScript errors.

```
grep -n "sageMode" frontend/src/store/resultsSlice.ts
grep -n "setSageMode" frontend/src/store/filterSlice.ts
grep -n "sageMode" frontend/src/hooks/useExplore.ts
grep -n "setSageMode" frontend/src/hooks/useSage.ts
grep -n "setSortBy" frontend/src/store/filterSlice.ts
```

`setSortBy` in filterSlice.ts does NOT contain a `setSageMode` call — sorting must not exit sage mode.
</verification>

<success_criteria>
The sageMode state machine is fully wired:
- Normal mode: useExplore watches filter state, fetches /api/explore
- Sage mode (sageMode=true): useExplore early-returns, useSage has injected results via setResults
- Exit sage mode: any filter action → setSageMode(false) → useExplore re-fetches

All changes are backward-compatible: the apply_filters path is unchanged, tracking is unchanged, loadNextPage is unchanged.
</success_criteria>

<output>
After completion, create `.planning/phases/32-sage-direct-search/32-02-SUMMARY.md` following the summary template.
</output>
