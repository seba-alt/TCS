---
phase: 37-backend-endpoints
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/routers/browse.py
  - app/main.py
  - requirements.txt
autonomous: true
requirements: [PHOTO-02]

must_haves:
  truths:
    - "GET /api/browse returns JSON with featured array (3-5 experts) and rows array (category rows with 3+ experts each)"
    - "GET /api/browse supports ?per_row=N query param (default 10, max 30)"
    - "GET /api/browse returns cold-start fallback (single All Experts row) when no categories meet 3+ threshold"
    - "GET /api/photos/{username} proxies image bytes from stored photo_url with correct Content-Type"
    - "GET /api/photos/{username} returns 404 when expert not found or has no photo_url"
    - "GET /api/photos/{username} includes Cache-Control: public, max-age=86400 header"
    - "Photo proxy rewrites http:// to https:// before fetching upstream"
  artifacts:
    - path: "app/routers/browse.py"
      provides: "Browse API and photo proxy endpoints"
      min_lines: 80
    - path: "app/main.py"
      provides: "Browse router registration"
      contains: "browse.router"
  key_links:
    - from: "app/routers/browse.py"
      to: "app/models.py"
      via: "SQLAlchemy Expert model queries"
      pattern: "Expert\\.category|Expert\\.findability_score"
    - from: "app/main.py"
      to: "app/routers/browse.py"
      via: "include_router registration"
      pattern: "app\\.include_router\\(browse\\.router\\)"
---

<objective>
Create the public Browse API endpoint (GET /api/browse) and photo proxy endpoint (GET /api/photos/{username}) in a new browse router, then register it in main.py.

Purpose: Backend serves curated Browse category rows and proxied expert photos so the Phase 38 Browse UI can be built against real data from day one.
Output: `app/routers/browse.py` with two GET endpoints, registered in `app/main.py`
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-backend-endpoints/37-CONTEXT.md
@.planning/phases/37-backend-endpoints/37-RESEARCH.md
@.planning/phases/36-foundation/36-02-SUMMARY.md
@app/routers/explore.py
@app/models.py
@app/main.py
@requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create browse router with GET /api/browse and GET /api/photos/{username}</name>
  <files>app/routers/browse.py, requirements.txt</files>
  <action>
Create new file `app/routers/browse.py` following the same pattern as `app/routers/explore.py` (public, no auth).

**Router setup:**
- `router = APIRouter()` — no prefix, no auth dependencies
- Import: `from app.database import get_db`, `from app.models import Expert`

**Move `httpx` from dev/testing section to core section in `requirements.txt`** — it is needed at runtime for photo proxy. Keep version `httpx==0.28.*`.

**GET /api/browse endpoint:**
- Async endpoint at `/api/browse`
- Query param: `per_row: int = Query(default=10, ge=1, le=30)`
- Use `run_in_executor` for synchronous SQLAlchemy queries (same pattern as explore.py)

**Browse query logic (sync helper function `_build_browse_data`):**
1. **Category rows:** Query `SELECT category, COUNT(*) as cnt FROM experts WHERE category IS NOT NULL GROUP BY category HAVING cnt >= 3 ORDER BY cnt DESC`. For each qualifying category, fetch up to `per_row` experts ordered by `findability_score DESC NULLS LAST`.
2. **Special cross-category row:** Add a "Recently Added" row — experts ordered by `created_at DESC`, limit `per_row` (no category filter).
3. **Cold-start guard:** If zero category rows meet the 3+ threshold, return a single row with `title: "All Experts"`, `slug: "all"`, containing experts ordered by `findability_score DESC`, limit `per_row`.
4. **Featured:** Top 5 experts overall by `findability_score DESC`.

**Expert card serializer** (`_serialize_browse_card(expert: Expert) -> dict`):
```python
{
    "username": expert.username,
    "first_name": expert.first_name,
    "last_name": expert.last_name,
    "job_title": expert.job_title,
    "company": expert.company,
    "hourly_rate": expert.hourly_rate,
    "category": expert.category,
    "tags": json.loads(expert.tags or "[]"),
    "photo_url": f"/api/photos/{expert.username}" if expert.photo_url else None,
    "profile_url": expert.profile_url,
}
```
Note: `photo_url` in the card points to our proxy endpoint (not the raw stored URL). Returns `None` when no photo stored.

**Response shape:**
```json
{
    "featured": [<card>, ...],
    "rows": [
        {"title": "Finance", "slug": "finance", "experts": [<card>, ...], "total": 42},
        {"title": "Recently Added", "slug": "recently-added", "experts": [<card>, ...], "total": 530}
    ]
}
```
The `slug` is the lowercase category name with spaces replaced by hyphens. For "Recently Added", slug is `"recently-added"`. The `total` is the full count of experts in that category (not just the `per_row` slice).

**GET /api/photos/{username} endpoint:**
- Async endpoint at `/api/photos/{username}`
- Lookup expert by username using `db.execute(select(Expert).where(Expert.username == username))` — via `run_in_executor`
- If expert not found or `photo_url` is None/empty → raise `HTTPException(404, detail="Photo not found")`
- HTTPS enforcement: if stored `photo_url` starts with `http://`, replace with `https://`
- Use `httpx.AsyncClient` to fetch the upstream image (timeout=5.0 seconds)
- If upstream returns non-200, raise `HTTPException(502, detail="Upstream photo unavailable")`
- Return `StreamingResponse` with:
  - `content` = upstream response stream (use `iter_bytes()`)
  - `media_type` from upstream `Content-Type` header (fallback `"image/jpeg"`)
  - `headers={"Cache-Control": "public, max-age=86400"}` (24h cache)

Import `httpx` at module level. Use `httpx.AsyncClient()` as a context manager inside the endpoint (simple pattern — no global client needed at current scale).
  </action>
  <verify>
    <automated>cd /Users/sebastianhamers/Documents/TCS && python -c "from app.routers.browse import router; print('browse router imported OK')"</automated>
    <manual>Check that browse.py has both GET endpoints and correct response shapes</manual>
  </verify>
  <done>browse.py exists with GET /api/browse returning {featured, rows} and GET /api/photos/{username} returning proxied image bytes with Cache-Control header. httpx moved to core dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Register browse router in main.py</name>
  <files>app/main.py</files>
  <action>
In `app/main.py`:

1. Add `browse` to the router import line: change `from app.routers import admin, chat, email_capture, events, feedback, health, explore, newsletter, pilot, suggest` to include `browse` (alphabetical position: after `admin`, before `chat`).

2. Add `app.include_router(browse.router)` — place it after the `explore.router` line (keeping public endpoints grouped). The exact line to add after: `app.include_router(explore.router)`.

No other changes needed — CORSMiddleware in main.py already allows GET requests and the browse router has no prefix that needs configuring.
  </action>
  <verify>
    <automated>cd /Users/sebastianhamers/Documents/TCS && python -c "from app.main import app; routes = [r.path for r in app.routes]; assert '/api/browse' in routes, f'Missing /api/browse in {routes}'; assert '/api/photos/{username}' in routes, f'Missing /api/photos in {routes}'; print('Both browse endpoints registered')"</automated>
  </verify>
  <done>Browse router registered in main.py — both /api/browse and /api/photos/{username} are live FastAPI routes.</done>
</task>

</tasks>

<verification>
1. `python -c "from app.main import app; routes = [r.path for r in app.routes]; print([r for r in routes if 'browse' in r or 'photo' in r])"` — shows both endpoints
2. Start server locally (`uvicorn app.main:app`) and:
   - `curl http://localhost:8000/api/browse` → returns JSON with `featured` and `rows` arrays
   - `curl http://localhost:8000/api/browse?per_row=3` → rows have max 3 experts each
   - `curl http://localhost:8000/api/photos/nonexistent` → 404
3. Verify cold-start: if all experts have category populated, manually test with per_row to see category rows
</verification>

<success_criteria>
- GET /api/browse returns valid JSON with featured (3-5 experts) and rows (categories with 3+ experts, sorted by count, plus Recently Added)
- GET /api/photos/{username} returns proxied image with Cache-Control header, 404 for missing, 502 for upstream failure
- Photo proxy enforces HTTPS on upstream URLs
- Cold-start fallback returns All Experts row when no categories qualify
- httpx in core dependencies (not just dev)
- Both endpoints registered and accessible
</success_criteria>

<output>
After completion, create `.planning/phases/37-backend-endpoints/37-01-SUMMARY.md`
</output>
