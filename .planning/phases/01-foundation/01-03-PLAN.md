---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on:
  - "01-02"
files_modified:
  - app/main.py
  - app/routers/__init__.py
  - app/routers/health.py
  - Procfile
  - .env.example
autonomous: false

requirements:
  - REC-01

must_haves:
  truths:
    - "FastAPI server starts without errors when `data/faiss.index` exists on disk"
    - "`GET /api/health` returns HTTP 200 with JSON body containing `status: ok` and `index_size` (number of vectors loaded)"
    - "The health response `index_size` is non-zero — confirming the FAISS index was loaded into memory"
    - "CORS is configured before any routes: `Access-Control-Allow-Origin` header is present on API responses"
    - "No secret values appear in any committed source file"
  artifacts:
    - path: "app/main.py"
      provides: "FastAPI app with lifespan-managed FAISS singleton, CORS middleware"
      contains: "asynccontextmanager"
      min_lines: 50
    - path: "app/routers/health.py"
      provides: "GET /api/health endpoint"
      exports: ["router"]
      contains: "index_size"
    - path: "Procfile"
      provides: "Railway deployment entry point"
      contains: "uvicorn app.main:app"
    - path: ".env.example"
      provides: "Documentation of required environment variables (safe to commit)"
      contains: "GOOGLE_API_KEY"
  key_links:
    - from: "app/main.py"
      to: "data/faiss.index"
      via: "faiss.read_index() in lifespan startup"
      pattern: "faiss\\.read_index"
    - from: "app/main.py"
      to: "app/routers/health.py"
      via: "app.include_router(health.router)"
      pattern: "include_router"
    - from: "app/routers/health.py"
      to: "app.state.faiss_index"
      via: "request.app.state.faiss_index"
      pattern: "request\\.app\\.state\\.faiss_index"
---

<objective>
Wire the FastAPI server: lifespan-managed FAISS loading, CORS middleware, and the health endpoint that proves the index loaded into memory.

Purpose: This is the final proof that Phase 1 is complete. A running server that responds `GET /api/health` with the correct vector count confirms that the offline-built index round-trips correctly through FastAPI's startup sequence — the exact dependency check Phase 2 needs before building retrieval.

Output: `app/main.py`, `app/routers/health.py`, `Procfile`, `.env.example` and a verified running server.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/1-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FastAPI app with lifespan and CORS</name>
  <files>app/main.py, app/routers/__init__.py, app/routers/health.py, Procfile, .env.example</files>
  <action>
Create `app/routers/__init__.py` — empty file.

Create `app/routers/health.py`:

```python
"""
Health check endpoint.

GET /api/health → {"status": "ok", "index_size": <int>}

index_size is the number of expert vectors loaded in the FAISS index.
A non-zero index_size confirms the FAISS index loaded successfully at startup.
"""
from fastapi import APIRouter, Request

router = APIRouter()


@router.get("/api/health")
async def health(request: Request) -> dict:
    index = request.app.state.faiss_index
    return {
        "status": "ok",
        "index_size": index.ntotal,
    }
```

Create `app/main.py`:

```python
"""
FastAPI application entry point.

Startup sequence (lifespan):
1. Load FAISS index from disk → app.state.faiss_index
2. Load metadata JSON → app.state.metadata
3. Yield (server is ready)
4. Shutdown: nothing to clean up for in-memory FAISS

CORS: configured before route registration.
Uses ALLOWED_ORIGINS env var (comma-separated).
Default: localhost:5173 (Vite dev server).
Production: Railway injects the actual Vercel URL.
"""
import json
import os
from contextlib import asynccontextmanager
from pathlib import Path

import faiss
import structlog
from dotenv import load_dotenv
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from app.config import FAISS_INDEX_PATH, METADATA_PATH
from app.routers import health

# Load .env for local development — no-op in production (Railway injects env vars)
load_dotenv()

log = structlog.get_logger()


@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Load FAISS index and metadata at startup; nothing to release at shutdown.
    Using lifespan (NOT @app.on_event — that pattern is deprecated in FastAPI 0.90+).
    """
    log.info("startup: loading FAISS index", path=str(FAISS_INDEX_PATH))

    if not FAISS_INDEX_PATH.exists():
        raise RuntimeError(
            f"FAISS index not found at {FAISS_INDEX_PATH}. "
            "Run scripts/ingest.py before starting the server."
        )

    app.state.faiss_index = faiss.read_index(str(FAISS_INDEX_PATH))
    log.info("startup: FAISS index loaded", vectors=app.state.faiss_index.ntotal)

    if not METADATA_PATH.exists():
        raise RuntimeError(f"Metadata not found at {METADATA_PATH}.")

    with open(METADATA_PATH, "r", encoding="utf-8") as f:
        app.state.metadata = json.load(f)
    log.info("startup: metadata loaded", records=len(app.state.metadata))

    yield
    # Shutdown: in-memory FAISS index is garbage-collected automatically


# --- Application ---
app = FastAPI(
    title="Tinrate AI Concierge",
    description="RAG-based expert recommendation API",
    version="0.1.0",
    lifespan=lifespan,
)

# --- CORS ---
# NEVER use ["*"] in production — use explicit Vercel domain.
# ALLOWED_ORIGINS env var is comma-separated; Railway injects the Vercel URL at deploy time.
_raw_origins = os.getenv("ALLOWED_ORIGINS", "http://localhost:5173")
ALLOWED_ORIGINS = [o.strip() for o in _raw_origins.split(",") if o.strip()]

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=False,
    allow_methods=["GET", "POST"],
    allow_headers=["Content-Type"],
)

# --- Routes ---
app.include_router(health.router)
```

Create `Procfile` (Railway deployment entry point):

```
web: uvicorn app.main:app --host 0.0.0.0 --port $PORT
```

Create `.env.example` (committed — documents required variables without exposing values):

```bash
# Copy to .env and fill in values. Never commit .env.
# The real .env is gitignored.

# Google AI API key — get from https://aistudio.google.com/
GOOGLE_API_KEY=your_key_here

# CORS allowed origins (comma-separated).
# In production, Railway injects the exact Vercel URL here.
# Default for local dev: Vite dev server
ALLOWED_ORIGINS=http://localhost:5173
```

PITFALLS to avoid:
- Use `@asynccontextmanager lifespan` pattern — NOT `@app.on_event("startup")` (deprecated in FastAPI 0.90+)
- Use absolute paths from `app.config` for FAISS index — NOT relative `"data/faiss.index"` strings (breaks when CWD differs from repo root)
- Never hardcode API key or origins — always read from environment
  </action>
  <verify>
1. `python -m py_compile app/main.py app/routers/health.py && echo "syntax OK"`
2. `python -c "from app.main import app; print('app importable')"` — note: this will fail if FAISS index doesn't exist yet; that's expected at import time — the index is loaded by the lifespan which only runs when uvicorn starts
3. `cat Procfile | grep "uvicorn app.main:app"` — Procfile must reference correct module path
4. `cat .env.example | grep "GOOGLE_API_KEY"` — .env.example must document the key (without value)
5. `git status .env.example` — .env.example must appear as an untracked file (NOT gitignored — it is safe to commit)
  </verify>
  <done>`app/main.py` uses `asynccontextmanager` lifespan, reads FAISS path from `app.config`, adds CORS middleware from `ALLOWED_ORIGINS` env var. `app/routers/health.py` exports `router` with `GET /api/health`. `Procfile` contains correct Railway entry point. `.env.example` is safe to commit and documents required variables.</done>
</task>

<task type="auto">
  <name>Task 2: Start FastAPI server and verify health endpoint</name>
  <files></files>
  <action>
Start the FastAPI server and verify all Phase 1 success criteria are met.

Prerequisites check before starting:
1. Confirm `data/faiss.index` exists: `ls -la data/faiss.index`
2. Confirm `.env` exists with `GOOGLE_API_KEY` set: `ls -la .env`
3. Confirm Python environment has all requirements: `pip install -r requirements.txt`

Start the server in the background:
```bash
uvicorn app.main:app --reload --host 127.0.0.1 --port 8000 &
SERVER_PID=$!
sleep 3  # Wait for startup
```

Run verification checks:

**Check 1 — Health endpoint returns 200:**
```bash
curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:8000/api/health
# Must print: 200
```

**Check 2 — Health response has correct shape:**
```bash
curl -s http://127.0.0.1:8000/api/health | python -m json.tool
# Must print JSON with "status": "ok" and "index_size": <non-zero number>
```

**Check 3 — CORS header is present:**
```bash
curl -s -I -H "Origin: http://localhost:5173" http://127.0.0.1:8000/api/health | grep -i "access-control"
# Must print: access-control-allow-origin: http://localhost:5173
```

**Check 4 — Embedder service returns 768-dim vector (Phase 1 Success Criterion 4):**
```bash
python -c "
from app.services.embedder import embed_query
v = embed_query('I need an ML engineer for my startup')
assert len(v) == 768, f'Expected 768, got {len(v)}'
print(f'embed_query OK: {len(v)}-dim vector')
"
```

After checks, stop the background server:
```bash
kill $SERVER_PID 2>/dev/null || true
```

If `data/faiss.index` does not exist (CSV not yet provided), document this clearly in the summary. The server startup will fail until the index is built — that is expected behavior, not a bug.
  </action>
  <verify>
1. `curl -s http://127.0.0.1:8000/api/health | python -c "import sys,json; d=json.load(sys.stdin); assert d['status']=='ok'; assert d['index_size'] > 0; print('health OK')"` — must pass
2. `curl -s -I -H "Origin: http://localhost:5173" http://127.0.0.1:8000/api/health | grep -i "access-control-allow-origin"` — must return `http://localhost:5173`
3. `python -c "from app.services.embedder import embed_query; v = embed_query('test'); assert len(v) == 768; print('768-dim OK')"` — must pass (requires GOOGLE_API_KEY)
  </verify>
  <done>FastAPI server starts and responds to `GET /api/health` with `{"status": "ok", "index_size": N}` where N > 0. CORS allows `http://localhost:5173`. `embed_query()` returns a 768-dim vector. All four Phase 1 success criteria are verifiable.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Human verification — Phase 1 Foundation complete</name>
  <action>All automated tasks complete. Human verifies the full Phase 1 foundation by running the checks described below.</action>
  <what-built>
Complete Phase 1 Foundation:
- Project scaffold: .gitignore, requirements.txt, .env.example
- CSV validation script: scripts/validate_csv.py
- Embedder service: app/services/embedder.py (returns 768-dim vectors)
- Offline ingestion: scripts/ingest.py (CSV → FAISS index)
- FastAPI server: app/main.py with lifespan FAISS loading + CORS
- Health endpoint: GET /api/health → {"status": "ok", "index_size": N}
  </what-built>
  <how-to-verify>
Run these checks in order:

1. Secrets check (no secrets in git):
   `git log --oneline | head -5` and `git diff HEAD` — confirm .env is not tracked

2. Health endpoint (requires data/faiss.index to exist):
   Start server: `uvicorn app.main:app --host 127.0.0.1 --port 8000`
   In another terminal: `curl http://127.0.0.1:8000/api/health`
   Expected: `{"status":"ok","index_size":1600}` (approximate — exact count from your CSV)
   index_size must be > 0

3. Embedder returns 768 dims (requires GOOGLE_API_KEY in .env):
   `python -c "from app.services.embedder import embed_query; v = embed_query('test query'); print(len(v))"`
   Expected output: `768`

4. CORS is configured:
   `curl -I -H "Origin: http://localhost:5173" http://127.0.0.1:8000/api/health | grep access-control`
   Expected: `access-control-allow-origin: http://localhost:5173`

5. Confirm gitignore works:
   `ls data/` — faiss.index and metadata.json should exist but `git status` should NOT show them

Type "approved" if all checks pass, or describe any issue.
  </how-to-verify>
  <verify>Human confirms all 5 checks pass by typing "approved".</verify>
  <done>Human has typed "approved" confirming all Phase 1 success criteria are met.</done>
  <resume-signal>Type "approved" to proceed to Phase 2, or describe the issue and Claude will fix it.</resume-signal>
</task>

</tasks>

<verification>
1. `curl -s http://127.0.0.1:8000/api/health` → `{"status": "ok", "index_size": N}` with N > 0
2. CORS header present: `Access-Control-Allow-Origin: http://localhost:5173`
3. `embed_query("test") → len(result) == 768`
4. `git status` shows no .env, data/faiss.index, data/metadata.json tracked
5. `cat Procfile` → `web: uvicorn app.main:app --host 0.0.0.0 --port $PORT`
</verification>

<success_criteria>
All four Phase 1 success criteria verified:
1. `scripts/ingest.py` produces `data/faiss.index` + `data/metadata.json` without errors
2. FastAPI server starts, loads FAISS index, responds to `GET /api/health` with HTTP 200 and non-zero `index_size`
3. `.env` is gitignored — `GOOGLE_API_KEY` never appears in git history
4. `embed_query("test query")` returns a list of exactly 768 floats
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
