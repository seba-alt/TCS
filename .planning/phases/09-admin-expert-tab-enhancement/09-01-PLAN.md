---
phase: 09-admin-expert-tab-enhancement
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - app/routers/admin.py
autonomous: true
requirements:
  - ADMIN-01
  - ADMIN-02
  - ADMIN-03
  - ADMIN-04
  - ADMIN-05
  - ADMIN-06
  - SEARCH-07

must_haves:
  truths:
    - "GET /api/admin/experts returns tags as a parsed JSON array (not raw string) for every expert"
    - "GET /api/admin/experts returns findability_score as a float or null for every expert"
    - "GET /api/admin/experts default order is ascending findability_score with nulls first"
    - "GET /api/admin/domain-map returns top-10 tag domains by downvote frequency as a ranked list"
    - "GET /api/admin/domain-map returns empty domains array gracefully when no downvotes exist"
  artifacts:
    - path: "app/routers/admin.py"
      provides: "Updated _serialize_expert(), sorted GET /api/admin/experts, new GET /api/admin/domain-map endpoint"
      contains: "tags.*json.loads"
  key_links:
    - from: "app/routers/admin.py _serialize_expert()"
      to: "Expert.tags column"
      via: "json.loads(e.tags or '[]')"
      pattern: "json\\.loads\\(e\\.tags"
    - from: "app/routers/admin.py get_domain_map()"
      to: "Feedback.expert_ids column"
      via: "select(Feedback.expert_ids).where(Feedback.vote == 'down')"
      pattern: "Feedback\\.vote.*down"
    - from: "app/routers/admin.py get_domain_map()"
      to: "Expert.profile_url"
      via: "Expert.profile_url.in_(list(url_set))"
      pattern: "profile_url\\.in_"
---

<objective>
Extend the backend Admin API with two changes: (1) enrich the expert serialization to expose `tags` and `findability_score`, change the default list order to worst-findability-first, and (2) add a new `GET /api/admin/domain-map` endpoint that returns the top-10 expert tag domains by downvote frequency.

Purpose: These backend changes are the foundation for the frontend Expert tab overhaul. The frontend cannot render tags, scores, or the domain-map section without this API contract.
Output: Modified `app/routers/admin.py` with updated `_serialize_expert()`, updated `GET /api/admin/experts` query, and new `GET /api/admin/domain-map` endpoint.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@app/routers/admin.py
@app/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enrich _serialize_expert() and fix default sort order</name>
  <files>app/routers/admin.py</files>
  <action>
    Two targeted edits to app/routers/admin.py:

    EDIT 1 — Update _serialize_expert():
    Find the existing `_serialize_expert(e: Expert)` function. Add two new fields to the returned dict:
    - `"tags": json.loads(e.tags or "[]")` — parses the JSON text column into a Python list. `json` is already imported at the top of admin.py; do NOT add a second import.
    - `"findability_score": e.findability_score` — float or None, passed through directly.

    The complete updated return dict should be:
    ```python
    return {
        "username": e.username,
        "first_name": e.first_name,
        "last_name": e.last_name,
        "job_title": e.job_title,
        "company": e.company,
        "bio": e.bio,
        "hourly_rate": e.hourly_rate,
        "profile_url": e.profile_url,
        "category": e.category,
        "tags": json.loads(e.tags or "[]"),
        "findability_score": e.findability_score,
    }
    ```

    EDIT 2 — Change GET /api/admin/experts default sort:
    Find the query inside `get_experts()` that fetches all experts. Change the `.order_by()` clause from `last_name, first_name` alphabetical ordering to `Expert.findability_score.asc().nulls_first()`. This sorts worst-quality experts (lowest scores) to the top.

    The updated query becomes:
    ```python
    experts = db.scalars(
        select(Expert).order_by(Expert.findability_score.asc().nulls_first())
    ).all()
    ```

    Do NOT change any other logic in get_experts() — pagination params, auth dependency, response model, etc. remain as-is.
  </action>
  <verify>
    Start the backend locally: `cd /Users/sebastianhamers/Documents/TCS && uvicorn app.main:app --reload --port 8000`
    Then in a second terminal:
    ```
    curl -s -H "X-Admin-Key: $(grep ADMIN_KEY .env | cut -d= -f2)" http://localhost:8000/api/admin/experts | python3 -c "import json,sys; experts=json.load(sys.stdin); e=experts[0]; print('tags type:', type(e['tags']).__name__); print('score:', e.get('findability_score')); print('first tags:', e['tags'][:2])"
    ```
    Expected: `tags type: list` (not `str`), score is a number or null, tags shows array items (not a JSON string).
  </verify>
  <done>
    GET /api/admin/experts response includes `tags` as a Python list (not a JSON string) and `findability_score` as float or null for every expert. The first expert in the list has the lowest (or null) findability_score, confirming worst-first sort.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add GET /api/admin/domain-map endpoint</name>
  <files>app/routers/admin.py</files>
  <action>
    Add a new endpoint to app/routers/admin.py registered on the auth-gated `router` (NOT `auth_router`). The endpoint uses the `_require_admin` dependency that is already applied to `router` via `dependencies=[Depends(_require_admin)]`.

    Add the following endpoint after the existing `get_experts` endpoint:

    ```python
    @router.get("/domain-map")
    def get_domain_map(db: Session = Depends(get_db)):
        """
        Return top-10 expert tag domains by frequency in downvoted results.
        Joins downvoted Feedback rows to Expert tags via profile_url lookup.
        Response: {"domains": [{"domain": str, "count": int}]}
        """
        from collections import Counter

        # Fetch only expert_ids column from downvoted feedback rows
        downvote_expert_ids = db.scalars(
            select(Feedback.expert_ids).where(Feedback.vote == "down")
        ).all()

        # Parse URLs/names from each row's JSON list
        url_set: set[str] = set()
        for raw in downvote_expert_ids:
            for entry in json.loads(raw or "[]"):
                url_set.add(entry)

        if not url_set:
            return {"domains": []}

        # Look up experts by profile_url — name-only fallback entries will not match (acceptable)
        experts = db.scalars(
            select(Expert).where(Expert.profile_url.in_(list(url_set)))
        ).all()

        # Count tag frequency across all matched experts
        tag_counter: Counter = Counter()
        for expert in experts:
            for tag in json.loads(expert.tags or "[]"):
                tag_counter[tag.lower().strip()] += 1

        return {
            "domains": [
                {"domain": d, "count": c}
                for d, c in tag_counter.most_common(10)
            ]
        }
    ```

    Key implementation notes:
    - `Feedback` is already imported at the top of admin.py (from app.models import Conversation, Expert, Feedback) — do NOT add a duplicate import.
    - `json` is already imported — do NOT add a duplicate import.
    - `select` from sqlalchemy is already imported — do NOT add a duplicate import.
    - Use `Expert.profile_url.in_(list(url_set))` NOT `Expert.username.in_()` — stored expert_ids are profile URLs, not usernames. Using username would return zero results.
    - The `from collections import Counter` is placed inside the function body to keep the module-level import surface clean (one-time use).
    - Empty-case guard (`if not url_set: return {"domains": []}`) prevents an expensive empty `.in_()` query on SQLite.
  </action>
  <verify>
    With backend running locally:
    ```
    curl -s -H "X-Admin-Key: $(grep ADMIN_KEY .env | cut -d= -f2)" http://localhost:8000/api/admin/domain-map | python3 -m json.tool
    ```
    Expected: Response is `{"domains": [...]}` — either an empty list (if no downvotes in local DB) or a list of `{"domain": str, "count": int}` objects with at most 10 entries. The endpoint must not return a 404 or 500.

    Also verify the endpoint requires auth:
    ```
    curl -s http://localhost:8000/api/admin/domain-map
    ```
    Expected: 401 or 403 response (not 200).
  </verify>
  <done>
    GET /api/admin/domain-map exists, returns `{"domains": [...]}` with proper schema, requires X-Admin-Key header, and returns at most 10 entries ranked by downvote count. The endpoint does not crash when the DB has no downvoted feedback rows.
  </done>
</task>

</tasks>

<verification>
Run the backend locally and verify both endpoints:
1. `GET /api/admin/experts` — first expert has lowest findability_score (or null), response includes `tags` array and `findability_score` field on every expert object
2. `GET /api/admin/domain-map` — returns `{"domains": [...]}` with 0–10 entries, requires auth header
3. No Python import errors on startup (`uvicorn app.main:app` starts cleanly)
</verification>

<success_criteria>
- `_serialize_expert()` returns `tags: list[str]` (parsed from JSON, never a string) and `findability_score: float | None`
- `GET /api/admin/experts` defaults to ascending findability_score with nulls first
- `GET /api/admin/domain-map` exists, is auth-gated, and returns the correct schema
- All existing admin endpoints still work (no regressions introduced by editing admin.py)
</success_criteria>

<output>
After completion, create `.planning/phases/09-admin-expert-tab-enhancement/09-01-SUMMARY.md`
</output>
