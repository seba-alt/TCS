---
phase: 06-thumbs-up-down-feedback-rate-results-downvote-opens-suggestion-sheet-feedback-stored-in-db
plan: 03
type: execute
wave: 2
depends_on:
  - "06-01"
  - "06-02"
files_modified:
  - frontend/src/App.tsx
  - frontend/src/components/ChatMessage.tsx
autonomous: false

requirements: []

must_haves:
  truths:
    - "FeedbackBar appears below the expert cards on the most recent result set only"
    - "FeedbackBar does not appear on clarification messages (no experts)"
    - "FeedbackBar renders whether or not the email gate is showing (voting doesn't require email unlock)"
    - "Clicking thumbs-up fills the up thumb in brand-purple and records the vote in the DB"
    - "Clicking thumbs-down fills the down thumb in red and opens the DownvoteModal"
    - "Clicking the modal backdrop or Escape closes it without error"
    - "Vote state resets on page reload (no localStorage persistence)"
    - "FeedbackBar does not appear on earlier chat turns when a new result set arrives"
  artifacts:
    - path: "frontend/src/App.tsx"
      provides: "email prop threaded to ChatMessage"
      contains: "email={email"
    - path: "frontend/src/components/ChatMessage.tsx"
      provides: "FeedbackBar rendered below expert cards on isLastExpertMessage"
      contains: "FeedbackBar"
  key_links:
    - from: "frontend/src/App.tsx"
      to: "frontend/src/components/ChatMessage.tsx"
      via: "email prop"
      pattern: "email=\\{email"
    - from: "frontend/src/components/ChatMessage.tsx"
      to: "frontend/src/components/FeedbackBar.tsx"
      via: "conditional render on isLastExpertMessage && message.conversationId"
      pattern: "isLastExpertMessage.*FeedbackBar|FeedbackBar.*isLastExpertMessage"
---

<objective>
Wire FeedbackBar into the chat UI: thread the email prop through App.tsx → ChatMessage, then render FeedbackBar below expert cards on the last expert message only.

Purpose: Plans 01 and 02 built all the pieces; this plan is the final wiring step. Two file modifications connect everything.
Output: FeedbackBar visible in the running app below the most recent expert result set; human verification confirms the full interaction flow end-to-end.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-thumbs-up-down-feedback-rate-results-downvote-opens-suggestion-sheet-feedback-stored-in-db/06-01-SUMMARY.md
@.planning/phases/06-thumbs-up-down-feedback-rate-results-downvote-opens-suggestion-sheet-feedback-stored-in-db/06-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Thread email prop through App.tsx and wire FeedbackBar into ChatMessage.tsx</name>
  <files>frontend/src/App.tsx, frontend/src/components/ChatMessage.tsx</files>
  <action>
    **In frontend/src/App.tsx** — add `email` prop to ChatMessage calls. The `email` value already exists in App.tsx from `const { isUnlocked, email, submitEmail } = useEmailGate()`. It just needs to be passed down to ChatMessage:

    Change the ChatMessage render call from:
    ```tsx
    <ChatMessage
      key={message.id}
      message={message}
      thinkingQuote={
        isLastAssistant && status === 'thinking'
          ? THINKING_QUOTES[quoteIndex]
          : undefined
      }
      isUnlocked={isUnlocked}
      onSubmitEmail={submitEmail}
      isLastExpertMessage={isLastExpertMessage}
    />
    ```

    To:
    ```tsx
    <ChatMessage
      key={message.id}
      message={message}
      thinkingQuote={
        isLastAssistant && status === 'thinking'
          ? THINKING_QUOTES[quoteIndex]
          : undefined
      }
      isUnlocked={isUnlocked}
      onSubmitEmail={submitEmail}
      isLastExpertMessage={isLastExpertMessage}
      email={email}
    />
    ```

    `email` from useEmailGate is `string | null` — this matches the FeedbackBar's `email: string | null` prop signature.

    **In frontend/src/components/ChatMessage.tsx** — make three changes:

    1. Add `email: string | null` to the Props interface:
    ```typescript
    interface Props {
      message: Message
      thinkingQuote?: string
      isUnlocked: boolean
      onSubmitEmail: (email: string) => Promise<void>
      isLastExpertMessage: boolean
      email: string | null
    }
    ```

    2. Add `email` to the destructured props:
    ```typescript
    export default function ChatMessage({ message, thinkingQuote, isUnlocked, onSubmitEmail, isLastExpertMessage, email }: Props) {
    ```

    3. Import FeedbackBar and render it below the expert cards block (after the optional EmailGate). The rendering condition: `isLastExpertMessage && message.conversationId` — both must be true. FeedbackBar renders whether the email gate is visible or not (voting doesn't require unlock):

    Add import at top (using `import` not `import type` since FeedbackBar is a value):
    ```typescript
    import FeedbackBar from './FeedbackBar'
    ```

    Add FeedbackBar render inside the expert cards `div.mt-3.space-y-3`, after the existing EmailGate conditional:
    ```tsx
    {isLastExpertMessage && message.conversationId !== undefined && (
      <FeedbackBar
        conversationId={message.conversationId}
        expertIds={message.experts?.map((e) => e.profile_url ?? e.name) ?? []}
        email={email}
      />
    )}
    ```

    Final structure of the expert cards section in ChatMessage.tsx:
    ```tsx
    {!isUser && message.experts && message.experts.length > 0 && (
      <div className="mt-3 space-y-3">
        {message.experts.map((expert, i) => (
          <ExpertCard
            key={expert.profile_url ?? `${expert.name}-${i}`}
            expert={expert}
            locked={!isUnlocked}
          />
        ))}
        {!isUnlocked && isLastExpertMessage && (
          <EmailGate onSubmit={onSubmitEmail} />
        )}
        {isLastExpertMessage && message.conversationId !== undefined && (
          <FeedbackBar
            conversationId={message.conversationId}
            expertIds={message.experts?.map((e) => e.profile_url ?? e.name) ?? []}
            email={email}
          />
        )}
      </div>
    )}
    ```

    This places FeedbackBar: expert cards → email gate (if locked) → feedback bar.

    After edits, run: `cd /Users/sebastianhamers/Documents/TCS/frontend && npx tsc --noEmit` and fix any TypeScript errors before proceeding.
  </action>
  <verify>
    Run: `cd /Users/sebastianhamers/Documents/TCS/frontend && npx tsc --noEmit 2>&1`
    Expected: 0 TypeScript errors
    Run: `cd /Users/sebastianhamers/Documents/TCS/frontend && npm run build 2>&1 | tail -10`
    Expected: build succeeds
    Run: `grep -n "FeedbackBar" frontend/src/components/ChatMessage.tsx` — confirms import and render
    Run: `grep -n "email={email" frontend/src/App.tsx` — confirms prop is threaded
    Run: `cd /Users/sebastianhamers/Documents/TCS && uvicorn app.main:app --host 0.0.0.0 --port 8000 &amp; sleep 3 &amp;&amp; curl -s http://localhost:8000/openapi.json | python3 -c "import sys,json; print([p for p in json.load(sys.stdin)['paths']])" &amp;&amp; kill %1`
    Expected: /api/feedback in the paths list
  </verify>
  <done>FeedbackBar imported and rendered in ChatMessage.tsx; email prop threaded from App.tsx; tsc --noEmit passes; npm run build succeeds</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Human verify end-to-end feedback flow in browser</name>
  <files>None — verification only</files>
  <action>Start dev servers and run through the 6 verification tests below. Fix any issues found before approving.</action>
  <verify>All 6 tests pass as described in how-to-verify below</verify>
  <done>Human types "approved" after confirming all 6 tests pass in a real browser</done>
  <what-built>
    Full thumbs up/down feedback feature:
    - Backend: Feedback model in DB, POST /api/feedback endpoint, conversation_id in SSE stream
    - Frontend: FeedbackBar with thumb SVGs below expert cards (last result set only), DownvoteModal with 4 checkboxes + optional free text, useFeedback hook managing state and API calls
    - Wiring: email threaded from App.tsx through ChatMessage to FeedbackBar; conversationId from SSE result event linked to feedback POST
  </what-built>
  <how-to-verify>
    Start the backend: `cd /Users/sebastianhamers/Documents/TCS && uvicorn app.main:app --reload`
    Start the frontend: `cd /Users/sebastianhamers/Documents/TCS/frontend && npm run dev`
    Visit: http://localhost:5173

    **Test 1 — FeedbackBar appears below results:**
    1. Submit a query (e.g. "I need help with React performance")
    2. Wait for expert cards to appear
    3. Verify: a small label "Were these results helpful?" appears below the expert cards
    4. Verify: two small thumb SVG buttons appear (up and down), unobtrusive size

    **Test 2 — Thumbs-up vote:**
    1. Click the thumbs-up button
    2. Verify: the thumbs-up fills with brand-purple color
    3. Verify: no modal opens
    4. Click thumbs-up again — nothing should happen (already selected)
    5. Click thumbs-down — it should switch: down fills red, up clears
    6. Check backend DB: `sqlite3 /Users/sebastianhamers/Documents/TCS/var/db.sqlite3 "SELECT * FROM feedback ORDER BY id DESC LIMIT 5;"`
       Expected: rows with vote='up' and vote='down' recorded

    **Test 3 — Thumbs-down opens modal:**
    1. Submit another query to get a fresh result
    2. Click the thumbs-down button
    3. Verify: thumbs-down fills red immediately
    4. Verify: centered modal dialog appears with title "Help us improve"
    5. Verify: 4 checkboxes visible ("Wrong experts shown", "Experts not relevant to my problem", "Experts seem unavailable or too expensive", "Other")
    6. Check "Other" — verify free-text field appears below checkboxes
    7. Click backdrop area outside the modal — modal should close
    8. Click thumbs-down again — nothing should happen (already selected)

    **Test 4 — Submit downvote detail:**
    1. Click thumbs-down again on a fresh result
    2. Select "Wrong experts shown" checkbox
    3. Click "Send feedback" button
    4. Verify: modal closes
    5. Check DB: `sqlite3 /Users/sebastianhamers/Documents/TCS/var/db.sqlite3 "SELECT vote, reasons, comment, conversation_id FROM feedback ORDER BY id DESC LIMIT 3;"`
       Expected: row with vote='down', reasons='["Wrong experts shown"]', conversation_id is a valid integer

    **Test 5 — Only last result set gets thumbs:**
    1. Submit a second query after the first
    2. Verify: FeedbackBar appears only below the new (second) result set
    3. Verify: the first result set no longer shows a FeedbackBar

    **Test 6 — Vote state resets on reload:**
    1. Vote thumbs-up on a result
    2. Refresh the page (F5)
    3. Submit the same query
    4. Verify: thumbs are un-filled (fresh state, no memory of prior vote)
  </how-to-verify>
  <resume-signal>Type "approved" when all 6 tests pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `tsc --noEmit` — zero TypeScript errors
2. `npm run build` — succeeds without errors
3. FeedbackBar renders below expert cards in browser (human verified)
4. Thumbs-up fills on click; thumbs-down fills and opens modal (human verified)
5. DB contains feedback rows with correct conversation_id, vote, expert_ids (human verified via sqlite3)
6. Only the most recent result set shows FeedbackBar (human verified)
</verification>

<success_criteria>
- App.tsx passes email prop to ChatMessage
- ChatMessage renders FeedbackBar below expert cards on isLastExpertMessage, gated on message.conversationId !== undefined
- End-to-end: query → expert cards → FeedbackBar → thumbs vote → DB row with conversation_id, vote, expert_ids
- Thumbs-up: fills purple, no modal
- Thumbs-down: fills red, opens DownvoteModal immediately, vote already in DB
- DownvoteModal: backdrop click and Escape close it; submitting sends reasons+comment as additional POST
- FeedbackBar disappears from prior turns when new result arrives
- All 6 human verification tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-thumbs-up-down-feedback-rate-results-downvote-opens-suggestion-sheet-feedback-stored-in-db/06-03-SUMMARY.md`
</output>
