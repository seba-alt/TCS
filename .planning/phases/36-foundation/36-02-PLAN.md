---
phase: 36-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/store/navigationSlice.ts
  - frontend/src/store/index.ts
  - app/models.py
  - app/main.py
autonomous: true
requirements:
  - SAGE-04
must_haves:
  truths:
    - "Zustand store has a navigationSlice with pendingSageResults field"
    - "navigationSlice is NOT persisted to localStorage"
    - "navigationSlice includes navigationSource field with type 'browse' | 'sage' | 'direct'"
    - "navigationSlice includes pendingSearchQuery field for contextual headers"
    - "pendingSageResults can be cleared after consumption"
    - "Expert SQLAlchemy model has a nullable photo_url column"
    - "Server starts without error on Railway (idempotent ALTER TABLE does not crash on restart)"
  artifacts:
    - path: "frontend/src/store/navigationSlice.ts"
      provides: "Navigation state slice for cross-page handoff"
      min_lines: 40
      exports: ["NavigationSlice", "createNavigationSlice"]
    - path: "frontend/src/store/index.ts"
      provides: "Combined store including NavigationSlice, not persisted"
      contains: "NavigationSlice"
    - path: "app/models.py"
      provides: "Expert model with photo_url column"
      contains: "photo_url"
    - path: "app/main.py"
      provides: "Idempotent ALTER TABLE for photo_url"
      contains: "photo_url"
  key_links:
    - from: "frontend/src/store/index.ts"
      to: "frontend/src/store/navigationSlice.ts"
      via: "slice import and spread into combined store"
      pattern: "createNavigationSlice"
    - from: "app/main.py"
      to: "app/models.py"
      via: "ALTER TABLE adding photo_url column matching ORM definition"
      pattern: "ALTER TABLE experts ADD COLUMN photo_url"
---

<objective>
Create the Zustand navigationSlice for cross-page state handoff and add the Expert.photo_url column to the backend model with idempotent migration.

Purpose: SAGE-04 requires a shared Zustand store with navigationSlice powering both Browse and Explorer pages. The photo_url column is a Phase 37 precondition that belongs in Foundation.
Output: navigationSlice.ts, updated store index.ts, updated Expert model + migration.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-foundation/36-CONTEXT.md
@.planning/phases/36-foundation/36-RESEARCH.md
@frontend/src/store/index.ts
@frontend/src/store/pilotSlice.ts
@frontend/src/store/resultsSlice.ts
@frontend/src/store/filterSlice.ts
@app/models.py
@app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create navigationSlice and integrate into combined store</name>
  <files>
    frontend/src/store/navigationSlice.ts
    frontend/src/store/index.ts
  </files>
  <action>
1. Create `frontend/src/store/navigationSlice.ts` following the exact same pattern as `pilotSlice.ts`:

```typescript
import type { StateCreator } from 'zustand'
import type { ExplorerStore } from './index'
import type { Expert } from './resultsSlice'

export interface NavigationSlice {
  // Navigation data fields — NOT persisted to localStorage
  navigationSource: 'browse' | 'sage' | 'direct'
  pendingSageResults: Expert[] | null
  pendingSearchQuery: string | null

  // Navigation actions
  setNavigationSource: (source: NavigationSlice['navigationSource']) => void
  setPendingSageResults: (experts: Expert[], query: string) => void
  clearPendingSageResults: () => void
}

export const createNavigationSlice: StateCreator<
  ExplorerStore,
  [['zustand/persist', unknown]],
  [],
  NavigationSlice
> = (set) => ({
  navigationSource: 'direct',
  pendingSageResults: null,
  pendingSearchQuery: null,

  setNavigationSource: (source) => set({ navigationSource: source }),

  setPendingSageResults: (experts, query) =>
    set({ pendingSageResults: experts, pendingSearchQuery: query }),

  clearPendingSageResults: () =>
    set({ pendingSageResults: null, pendingSearchQuery: null }),
})
```

Key decisions per CONTEXT.md:
- `pendingSageResults` stores full Expert objects (not just IDs) — matches the existing pattern where `resultsSlice` stores full Expert arrays via `setResults()`. The useSage hook already receives full expert objects from the pilot API, so storing full objects avoids a redundant lookup.
- `pendingSearchQuery` stores the Sage search text alongside results for contextual headers like "Showing results for: machine learning experts"
- `navigationSource` defaults to `'direct'` — this is critical for the resetPilot gate in Plan 01: direct URL visits get pilot reset, Browse transitions do not.
- `clearPendingSageResults` clears both results AND query together (atomic clear after consumption).

2. Update `frontend/src/store/index.ts`:

a) Add imports:
```typescript
import { createNavigationSlice } from './navigationSlice'
import type { NavigationSlice } from './navigationSlice'
```

b) Add to re-exports:
```typescript
export type { FilterSlice, ResultsSlice, PilotSlice, NavigationSlice }
```

c) Update combined store type:
```typescript
export type ExplorerStore = FilterSlice & ResultsSlice & PilotSlice & NavigationSlice
```

d) Add to the persist store creation (spread into the combined creator):
```typescript
(...a) => ({
  ...createFilterSlice(...a),
  ...createResultsSlice(...a),
  ...createPilotSlice(...a),
  ...createNavigationSlice(...a),
}),
```

e) The `partialize` function does NOT change — it only persists filter fields. NavigationSlice is ephemeral by exclusion (same pattern as ResultsSlice and PilotSlice).

f) Add a `useNavigationSlice` convenience hook following the existing pattern:
```typescript
export const useNavigationSlice = () =>
  useExplorerStore(
    useShallow((state) => ({
      navigationSource:        state.navigationSource,
      pendingSageResults:      state.pendingSageResults,
      pendingSearchQuery:      state.pendingSearchQuery,
      setNavigationSource:     state.setNavigationSource,
      setPendingSageResults:   state.setPendingSageResults,
      clearPendingSageResults: state.clearPendingSageResults,
    }))
  )
```

After this task, the store type `ExplorerStore` includes `NavigationSlice`, which means Plan 01's `(s as any).navigationSource` access becomes type-safe automatically if Plan 02 executes first. Either execution order works.
  </action>
  <verify>
    <automated>cd frontend && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Verify that navigationSlice.ts exports are correctly typed and index.ts includes the new slice.</manual>
  </verify>
  <done>
    - `navigationSlice.ts` exists with NavigationSlice interface and createNavigationSlice factory
    - Combined store type includes NavigationSlice
    - navigationSlice fields are NOT in partialize (not persisted)
    - useNavigationSlice convenience hook exported
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Expert.photo_url column with idempotent migration</name>
  <files>
    app/models.py
    app/main.py
  </files>
  <action>
1. Add `photo_url` column to the Expert model in `app/models.py`.

After the `findability_score` field (line 105) and before `created_at` (line 106), add:
```python
photo_url: Mapped[str | None] = mapped_column(String(500), nullable=True)
```

This matches the pattern of other nullable string fields like `category` and `profile_url`.

2. Add idempotent ALTER TABLE migration in `app/main.py` lifespan function.

Find the existing Phase 8 expert enrichment migration block (lines 208-219):
```python
# Phase 8: expert enrichment columns
with engine.connect() as _conn:
    for _col_ddl in [
        "ALTER TABLE experts ADD COLUMN tags TEXT",
        "ALTER TABLE experts ADD COLUMN findability_score REAL",
    ]:
```

Add a new migration block immediately after (following the same pattern):
```python
# Phase 36: expert photo URL column
with engine.connect() as _conn:
    for _col_ddl in [
        "ALTER TABLE experts ADD COLUMN photo_url TEXT",
    ]:
        try:
            _conn.execute(_text(_col_ddl))
            _conn.commit()
        except Exception:
            pass  # Column already exists — idempotent
log.info("startup: expert photo_url column migrated/verified")
```

This is Railway-safe:
- On fresh deploy: `Base.metadata.create_all` creates the experts table with photo_url from the ORM model. The ALTER TABLE then fails silently (column already exists). No crash.
- On restart (existing DB): ALTER TABLE fails silently if column was already added in a previous startup. No crash.
- On first run after this code deploys (existing DB without column): ALTER TABLE succeeds and adds the column.
  </action>
  <verify>
    <automated>cd /Users/sebastianhamers/Documents/TCS && python3 -c "from app.models import Expert; print('photo_url' in [c.key for c in Expert.__table__.columns])"</automated>
    <manual>Verify app/main.py has the Phase 36 migration block after the Phase 8 block.</manual>
  </verify>
  <done>
    - Expert model in app/models.py has nullable photo_url column (String(500))
    - app/main.py lifespan has idempotent ALTER TABLE for photo_url
    - Migration follows established project pattern (try/except with pass)
    - Server will not crash on Railway restart
  </done>
</task>

</tasks>

<verification>
- [ ] `npx tsc --noEmit` passes in frontend directory
- [ ] `python3 -c "from app.models import Expert; print('photo_url' in [c.key for c in Expert.__table__.columns])"` returns True
- [ ] navigationSlice.ts exports NavigationSlice type and createNavigationSlice factory
- [ ] index.ts ExplorerStore type includes NavigationSlice
- [ ] partialize does NOT include any navigation fields
- [ ] app/main.py has idempotent ALTER TABLE for photo_url after Phase 8 block
</verification>

<success_criteria>
SAGE-04 foundation met: Zustand store has a navigationSlice with `pendingSageResults`, `navigationSource`, and `pendingSearchQuery` fields. The slice is NOT persisted to localStorage (excluded from partialize). Expert model has a nullable `photo_url` column with an idempotent ALTER TABLE migration that will not crash on Railway restart.
</success_criteria>

<output>
After completion, create `.planning/phases/36-foundation/36-02-SUMMARY.md`
</output>
