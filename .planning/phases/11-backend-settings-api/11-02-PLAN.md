---
phase: 11-backend-settings-api
plan: "02"
type: execute
wave: 2
depends_on:
  - "11-01"
files_modified:
  - app/routers/admin.py
  - .env.example
autonomous: true
requirements:
  - CONF-03
  - CONF-04

must_haves:
  truths:
    - "GET /api/admin/settings returns all 5 settings with their current value and source (db or env)"
    - "POST /api/admin/settings writes a value to the settings table; immediate next GET reflects the change"
    - "Out-of-range values return HTTP 400 with a clear error message"
    - "Toggling a flag via POST causes the next chat request to use the updated value without redeploy"
  artifacts:
    - path: "app/routers/admin.py"
      provides: "GET and POST /api/admin/settings endpoints"
      contains: "settings"
    - path: ".env.example"
      provides: "Documentation of the 5 tuneable setting keys"
      contains: "STRONG_RESULT_MIN"
  key_links:
    - from: "app/routers/admin.py GET /api/admin/settings"
      to: "app/models.py AppSetting"
      via: "SQLAlchemy select query"
      pattern: "select.*AppSetting"
    - from: "app/routers/admin.py POST /api/admin/settings"
      to: "app/models.py AppSetting"
      via: "SQLAlchemy merge/upsert to settings table"
      pattern: "AppSetting.*key"
---

<objective>
Add GET and POST /api/admin/settings admin endpoints to admin.py, enabling the frontend (Phase 12) to read and write all 5 intelligence settings. Update .env.example to document the settable keys.

Purpose: This is the admin API surface for Phase 12's steering panel. Admins can read current runtime state (including whether a value comes from the DB or env var fallback) and write new values without touching Railway env vars.
Output: Two admin endpoints, validation logic, and updated .env.example documentation.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@app/routers/admin.py
@app/models.py
@app/services/search_intelligence.py
@.planning/phases/11-backend-settings-api/11-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: GET and POST /api/admin/settings endpoints</name>
  <files>app/routers/admin.py</files>
  <action>
Add settings endpoints to `app/routers/admin.py`. These go on the existing `router` (which already has `_require_admin` dependency applied at router level) — do NOT add to `auth_router`.

**Step 1: Define the 5 valid settings as a module-level dict near the top of the settings section.**

Add a constant `SETTINGS_SCHEMA` dict that describes each key's metadata. This powers both validation and the GET response metadata (useful for Phase 12 UI):

```python
# ── Settings schema ───────────────────────────────────────────────────────────

SETTINGS_SCHEMA: dict[str, dict] = {
    "QUERY_EXPANSION_ENABLED": {
        "type": "bool",
        "description": "Enable HyDE query expansion for weak queries",
        "env_default": "false",
    },
    "FEEDBACK_LEARNING_ENABLED": {
        "type": "bool",
        "description": "Enable feedback-weighted re-ranking of search results",
        "env_default": "false",
    },
    "SIMILARITY_THRESHOLD": {
        "type": "float",
        "description": "Minimum FAISS score to consider a result strong (0.0–1.0)",
        "env_default": "0.60",
        "min": 0.0,
        "max": 1.0,
    },
    "STRONG_RESULT_MIN": {
        "type": "int",
        "description": "Minimum strong results before HyDE expansion fires (1–10)",
        "env_default": "3",
        "min": 1,
        "max": 10,
    },
    "FEEDBACK_BOOST_CAP": {
        "type": "float",
        "description": "Maximum feedback score multiplier offset (0.0–0.50)",
        "env_default": "0.20",
        "min": 0.0,
        "max": 0.50,
    },
}
```

**Step 2: Add Pydantic request model for POST.**

```python
class SettingUpdate(BaseModel):
    key: str
    value: str  # Always accepted as string; validation converts to native type
```

**Step 3: Add validation helper.**

```python
def _validate_setting(key: str, value: str) -> None:
    """Raise HTTPException 400 if key is unknown or value is out of range."""
    if key not in SETTINGS_SCHEMA:
        valid_keys = ", ".join(SETTINGS_SCHEMA.keys())
        raise HTTPException(
            status_code=400,
            detail=f"Unknown setting key '{key}'. Valid keys: {valid_keys}",
        )
    schema = SETTINGS_SCHEMA[key]
    stype = schema["type"]
    try:
        if stype == "bool":
            if value.lower().strip() not in ("true", "false", "1", "0"):
                raise ValueError(f"must be true/false/1/0, got '{value}'")
        elif stype == "float":
            fval = float(value)
            if "min" in schema and fval < schema["min"]:
                raise ValueError(f"must be >= {schema['min']}, got {fval}")
            if "max" in schema and fval > schema["max"]:
                raise ValueError(f"must be <= {schema['max']}, got {fval}")
        elif stype == "int":
            ival = int(value)
            if "min" in schema and ival < schema["min"]:
                raise ValueError(f"must be >= {schema['min']}, got {ival}")
            if "max" in schema and ival > schema["max"]:
                raise ValueError(f"must be <= {schema['max']}, got {ival}")
    except ValueError as exc:
        raise HTTPException(status_code=400, detail=f"Invalid value for '{key}': {exc}") from exc
```

**Step 4: Helper to build native typed value from string.**

```python
def _coerce_value(key: str, raw: str):
    """Convert raw string DB value to native Python type for the response."""
    stype = SETTINGS_SCHEMA[key]["type"]
    if stype == "bool":
        return raw.lower().strip() in ("true", "1", "yes")
    if stype == "float":
        return float(raw)
    if stype == "int":
        return int(raw)
    return raw
```

**Step 5: GET /api/admin/settings**

```python
@router.get("/api/admin/settings")
def get_settings_endpoint(db: Session = Depends(get_db)):
    """
    Return all 5 intelligence settings with current value and source.

    source:
        "db"  — value comes from the settings table (DB override active)
        "env" — no DB row exists; value comes from Railway env var
        "default" — no DB row and no env var; using hardcoded default
    """
    from app.models import AppSetting  # deferred import avoids circular import at startup

    db_rows = {row.key: row.value for row in db.scalars(select(AppSetting)).all()}
    result = {}
    for key, schema in SETTINGS_SCHEMA.items():
        if key in db_rows:
            raw = db_rows[key]
            source = "db"
        elif os.getenv(key) is not None:
            raw = os.environ[key]
            source = "env"
        else:
            raw = schema["env_default"]
            source = "default"
        result[key] = {
            "value": _coerce_value(key, raw),
            "raw": raw,
            "source": source,
            "type": schema["type"],
            "description": schema["description"],
        }
    return {"settings": result}
```

**Step 6: POST /api/admin/settings**

Use SQLite upsert (INSERT OR REPLACE equivalent via merge pattern). The `AppSetting.key` is a primary key — use `db.merge()` for upsert semantics:

```python
@router.post("/api/admin/settings")
def update_setting(body: SettingUpdate, db: Session = Depends(get_db)):
    """
    Write or overwrite a single setting in the DB.

    Accepts a single key/value pair. The value is always stored as a string.
    Returns the updated setting entry.
    POST /api/admin/settings with {"key": "QUERY_EXPANSION_ENABLED", "value": "true"}
    """
    from app.models import AppSetting  # deferred import
    import datetime as _dt

    _validate_setting(body.key, body.value)

    # db.merge() performs INSERT or UPDATE based on primary key match.
    # AppSetting.key is the primary key — merge upserts cleanly.
    setting = db.merge(AppSetting(
        key=body.key,
        value=body.value,
        updated_at=_dt.datetime.utcnow(),
    ))
    db.commit()
    db.refresh(setting)

    log.info("admin.settings.updated", key=body.key, value=body.value)
    return {
        "key": setting.key,
        "value": _coerce_value(setting.key, setting.value),
        "raw": setting.value,
        "source": "db",
        "updated_at": setting.updated_at.isoformat(),
    }
```

**Imports to add at top of admin.py** (add to existing import block, do not duplicate existing imports):
- `from app.models import AppSetting` is deferred inside functions to avoid circular import
- `select` is already imported from sqlalchemy

Place these endpoint functions near the bottom of admin.py, after the existing domain-map endpoint, with a clear section comment: `# ── Settings ─────────────────────────────────`.
  </action>
  <verify>
Start the server: `uvicorn app.main:app --reload --port 8000`

1. Get all settings (no admin key needed locally for testing — but include it):
```
ADMIN_KEY=$(python -c "import os; from dotenv import load_dotenv; load_dotenv(); print(os.getenv('ADMIN_SECRET',''))")
curl -s http://localhost:8000/api/admin/settings -H "X-Admin-Key: $ADMIN_KEY" | python -m json.tool
```
Should return JSON with `settings` dict containing all 5 keys, each with `value`, `source: "default"` or `"env"`, `type`, `description`.

2. Write a setting:
```
curl -s -X POST http://localhost:8000/api/admin/settings \
  -H "Content-Type: application/json" \
  -H "X-Admin-Key: $ADMIN_KEY" \
  -d '{"key": "QUERY_EXPANSION_ENABLED", "value": "true"}' | python -m json.tool
```
Should return `{"key": "QUERY_EXPANSION_ENABLED", "value": true, "source": "db", ...}`.

3. Re-fetch GET — the updated key now shows `source: "db"`:
```
curl -s http://localhost:8000/api/admin/settings -H "X-Admin-Key: $ADMIN_KEY" | python -m json.tool
```
`QUERY_EXPANSION_ENABLED` should show `"source": "db"`, `"value": true`.

4. Out-of-range rejection:
```
curl -s -X POST http://localhost:8000/api/admin/settings \
  -H "Content-Type: application/json" \
  -H "X-Admin-Key: $ADMIN_KEY" \
  -d '{"key": "SIMILARITY_THRESHOLD", "value": "1.5"}' | python -m json.tool
```
Should return HTTP 400 with `{"detail": "Invalid value for 'SIMILARITY_THRESHOLD': must be <= 1.0, got 1.5"}`.

5. Unknown key rejection:
```
curl -s -X POST http://localhost:8000/api/admin/settings \
  -H "Content-Type: application/json" \
  -H "X-Admin-Key: $ADMIN_KEY" \
  -d '{"key": "INVALID_KEY", "value": "true"}' | python -m json.tool
```
Should return HTTP 400 with detail listing valid keys.

6. Clean up test setting:
```
sqlite3 data/conversations.db "DELETE FROM settings WHERE key='QUERY_EXPANSION_ENABLED';"
```
  </verify>
  <done>
GET /api/admin/settings returns all 5 settings with value, source, type, description.
POST /api/admin/settings writes to settings table; subsequent GET reflects change with source="db".
Out-of-range values return HTTP 400 (not 422, not silent clamp).
Unknown keys return HTTP 400.
Boolean flags accept true/false/1/0 string variants.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update .env.example with settings documentation</name>
  <files>.env.example</files>
  <action>
Read the existing `.env.example` file and append a new section documenting the 5 tuneable settings. Do NOT remove or modify any existing content — append only.

Add the following section at the end of `.env.example`:

```
# ── Search Intelligence Settings (Phase 11) ──────────────────────────────────
# These settings can be overridden at runtime via POST /api/admin/settings without redeploy.
# When a DB override exists, it takes precedence over these env vars.
# When neither a DB override nor an env var exists, the hardcoded default is used.

# Enable HyDE (Hypothetical Document Embedding) query expansion.
# Set to true in Railway after validating search quality improvement.
# DB-controllable: POST /api/admin/settings {"key": "QUERY_EXPANSION_ENABLED", "value": "true"}
QUERY_EXPANSION_ENABLED=false

# Enable feedback-weighted re-ranking (requires >= 10 feedback rows per expert).
# Set to true in Railway after accumulating sufficient feedback data.
# DB-controllable: POST /api/admin/settings {"key": "FEEDBACK_LEARNING_ENABLED", "value": "true"}
FEEDBACK_LEARNING_ENABLED=false

# Minimum FAISS cosine similarity score to consider a result "strong" (0.0–1.0).
# HyDE expansion is skipped when >= STRONG_RESULT_MIN candidates exceed this threshold.
# DB-controllable: POST /api/admin/settings {"key": "SIMILARITY_THRESHOLD", "value": "0.60"}
SIMILARITY_THRESHOLD=0.60

# Minimum number of strong results required before HyDE expansion is skipped (1–10).
# Lower = HyDE fires more aggressively. Default 3 means: expand if fewer than 3 strong results.
# DB-controllable: POST /api/admin/settings {"key": "STRONG_RESULT_MIN", "value": "3"}
STRONG_RESULT_MIN=3

# Maximum feedback score boost/penalty cap as a fraction (0.0–0.50).
# 0.20 = up to ±20% adjustment to FAISS similarity score. Cap prevents feedback from drowning signal.
# DB-controllable: POST /api/admin/settings {"key": "FEEDBACK_BOOST_CAP", "value": "0.20"}
FEEDBACK_BOOST_CAP=0.20
```
  </action>
  <verify>
`cat .env.example` — should show the new section at the bottom with all 5 keys documented.
`grep -c "DB-controllable" .env.example` — should return 5.
  </verify>
  <done>
.env.example contains all 5 settings keys with comments explaining the DB-override pattern and valid ranges.
  </done>
</task>

</tasks>

<verification>
End-to-end settings lifecycle test:

1. Server starts cleanly: `uvicorn app.main:app --reload --port 8000`
2. GET /api/admin/settings returns all 5 keys with source="default" or "env"
3. POST /api/admin/settings {"key": "QUERY_EXPANSION_ENABLED", "value": "true"} → 200, source="db"
4. GET /api/admin/settings → QUERY_EXPANSION_ENABLED shows source="db", value=true
5. Send chat request → check Railway-style log for hyde_triggered=true (if FAISS returns weak results)
6. POST /api/admin/settings {"key": "QUERY_EXPANSION_ENABLED", "value": "false"} → 200
7. Send chat request → hyde_triggered=false confirmed in log
8. POST with invalid range → 400 returned
9. POST with unknown key → 400 returned
</verification>

<success_criteria>
- GET /api/admin/settings returns all 5 settings; each has value (native type), source, type, description
- POST /api/admin/settings writes to DB; change reflected in next GET and next chat request
- Out-of-range values → HTTP 400 with descriptive message
- Unknown keys → HTTP 400 listing valid keys
- .env.example documents all 5 keys with Railway enable guidance and DB-override pattern
- ruff check passes: `ruff check app/routers/admin.py app/services/search_intelligence.py app/models.py`
</success_criteria>

<output>
After completion, create `.planning/phases/11-backend-settings-api/11-02-SUMMARY.md`
</output>
