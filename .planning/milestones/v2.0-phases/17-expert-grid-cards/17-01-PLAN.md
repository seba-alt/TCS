---
phase: 17-expert-grid-cards
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/store/resultsSlice.ts
  - frontend/src/hooks/useExplore.ts
autonomous: true
requirements: [MARKET-02, MARKET-03, MARKET-04]

must_haves:
  truths:
    - "Expert interface uses snake_case field names matching the /api/explore API response"
    - "resultsSlice exposes appendResults action that appends new experts to existing array"
    - "resultsSlice exposes isFetchingMore boolean and setFetchingMore action"
    - "useExplore hook exposes a loadNextPage callback that fetches the next cursor page and appends results"
    - "react-virtuoso and motion packages are installed and resolvable"
  artifacts:
    - path: "frontend/src/store/resultsSlice.ts"
      provides: "Expert interface (snake_case) + appendResults + isFetchingMore + setFetchingMore"
      contains: "appendResults"
    - path: "frontend/src/hooks/useExplore.ts"
      provides: "loadNextPage callback for VirtuosoGrid endReached"
      contains: "loadNextPage"
  key_links:
    - from: "frontend/src/hooks/useExplore.ts"
      to: "frontend/src/store/resultsSlice.ts"
      via: "appendResults action"
      pattern: "appendResults"
    - from: "frontend/src/store/resultsSlice.ts"
      to: "/api/explore response"
      via: "snake_case Expert interface alignment"
      pattern: "first_name|job_title|hourly_rate"
---

<objective>
Fix the Expert type mismatch and extend the results slice + useExplore hook to support infinite scroll. This is the data contract foundation everything in Phase 17 depends on.

Purpose: The current Expert interface uses camelCase field names (firstName, jobTitle) but the API returns snake_case (first_name, job_title). All card fields are currently undefined. This must be fixed before any card can render real data. The resultsSlice also lacks the appendResults action needed for cursor-based infinite scroll pagination.

Output: Corrected Expert interface, extended resultsSlice with append/fetchingMore state, extended useExplore with loadNextPage, and react-virtuoso + motion installed.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@frontend/src/store/resultsSlice.ts
@frontend/src/hooks/useExplore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install deps, fix Expert type to snake_case, extend resultsSlice with append/fetchingMore</name>
  <files>frontend/src/store/resultsSlice.ts</files>
  <action>
From the frontend/ directory run: npm install react-virtuoso motion

Then update frontend/src/store/resultsSlice.ts:

1. Fix Expert interface — rename ALL camelCase fields to snake_case to match /api/explore API response:
   - firstName → first_name (string)
   - lastName → last_name (string)
   - jobTitle → job_title (string)
   - company stays company
   - hourlyRate → hourly_rate (number)
   - ADD currency: string (missing field the API returns)
   - ADD profile_url: string (missing field the API returns)
   - tags stays tags: string[]
   - findabilityScore → findability_score: number | null
   - matchReason → match_reason: string | null
   - REMOVE any camelCase aliases, REMOVE faiss_score/bm25_score/final_score/category (not needed in UI)

2. Extend the ResultsSlice interface — add THREE new fields:
   - isFetchingMore: boolean
   - appendResults: (experts: Expert[], cursor: number | null) => void
   - setFetchingMore: (v: boolean) => void

3. Extend createResultsSlice implementation — add initial state and implementations:
   - isFetchingMore: false,
   - appendResults: (newExperts, cursor) => set((state) => ({ experts: [...state.experts, ...newExperts], cursor })),
   - setFetchingMore: (v) => set({ isFetchingMore: v }),

IMPORTANT: The existing setResults, resetResults, cursor, total, loading, setLoading, setResults, and experts fields must remain unchanged. Only ADD new fields and FIX the Expert interface field names. Do NOT change the actions signature of setResults — it still uses setResults(experts, total, cursor) for filter-change fetches.

After editing, run from frontend/: npm run build — fix any TypeScript errors before proceeding. Common errors will be TS complaints about old camelCase field access in components that reference resultsSlice.ts Expert type — update those references too if the build fails.
  </action>
  <verify>
    From frontend/ directory: npm run build — must exit 0 with no TypeScript errors.
    Confirm: grep -n "first_name\|last_name\|job_title\|hourly_rate" frontend/src/store/resultsSlice.ts returns hits showing the snake_case fields.
    Confirm: grep -n "appendResults\|isFetchingMore\|setFetchingMore" frontend/src/store/resultsSlice.ts returns hits for all three new items.
    Confirm: grep -n "react-virtuoso\|motion" frontend/package.json returns the new packages.
  </verify>
  <done>
    Expert interface has snake_case fields (first_name, last_name, job_title, hourly_rate, currency, profile_url, findability_score, match_reason).
    ResultsSlice has appendResults, isFetchingMore, setFetchingMore.
    npm run build passes with no TypeScript errors.
    react-virtuoso and motion appear in frontend/package.json dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend useExplore hook with loadNextPage for infinite scroll</name>
  <files>frontend/src/hooks/useExplore.ts</files>
  <action>
Update frontend/src/hooks/useExplore.ts to expose a loadNextPage callback that ExpertGrid will pass to VirtuosoGrid's endReached prop.

The existing useEffect handles filter-change fetches (uses setResults, resets state on filter change). Do NOT modify that logic. ADD a separate loadNextPage function:

1. Import appendResults, isFetchingMore, setFetchingMore from the store. Use individual selectors (not useShallow) consistent with the Phase 16 pattern — individual Zustand selectors prevent infinite re-render loops (see STATE.md Phase 16 decision).

2. Add this function inside the hook (not inside useEffect):
```typescript
const loadNextPage = useCallback(async () => {
  // Guard: don't fetch if no more pages, already fetching more, or initial load in progress
  if (cursor === null || isFetchingMore || loading) return
  setFetchingMore(true)
  try {
    const params = new URLSearchParams()
    if (query) params.set('q', query)
    params.set('rate_min', String(rateMin))
    params.set('rate_max', String(rateMax))
    tags.forEach((t) => params.append('tags', t))
    params.set('cursor', String(cursor))
    // Reuse the same VITE_API_URL base as the existing fetch call
    const res = await fetch(`${import.meta.env.VITE_API_URL}/api/explore?${params}`)
    if (!res.ok) return
    const data = await res.json()
    appendResults(data.experts, data.cursor ?? null)
  } catch {
    // silent — VirtuosoGrid will retry on next endReached trigger
  } finally {
    setFetchingMore(false)
  }
}, [cursor, isFetchingMore, loading, query, rateMin, rateMax, tags, appendResults, setFetchingMore])
```

3. Return loadNextPage from the hook alongside the existing return values.

IMPORTANT: Do NOT wrap loadNextPage in AbortController — it is not a filter-change fetch. The guard `if (cursor === null)` correctly stops fetching when the API signals no more pages (cursor: null means last page). The existing filter-change useEffect already calls resetResults() which clears the cursor to null before the new fetch, preventing loadNextPage from firing during a filter change.

After editing, run: npm run build from frontend/ — must pass.
  </action>
  <verify>
    From frontend/ directory: npm run build — must exit 0 with no TypeScript errors.
    grep -n "loadNextPage\|appendResults\|isFetchingMore" frontend/src/hooks/useExplore.ts — all three appear.
    grep -n "return.*loadNextPage" frontend/src/hooks/useExplore.ts — loadNextPage is included in the hook's return value.
  </verify>
  <done>
    useExplore hook exports loadNextPage callback.
    loadNextPage guards on cursor === null, isFetchingMore, loading.
    loadNextPage calls appendResults (not setResults) on success.
    npm run build passes.
  </done>
</task>

</tasks>

<verification>
Run from frontend/ directory: npm run build — must exit 0.
Run: grep -rn "firstName\|jobTitle\|hourlyRate\|findabilityScore\|matchReason" frontend/src/store/resultsSlice.ts — must return NO results (all camelCase fields eliminated from Expert interface).
Run: grep -n "appendResults\|isFetchingMore\|loadNextPage" frontend/src/store/resultsSlice.ts frontend/src/hooks/useExplore.ts — all three appear in both files.
</verification>

<success_criteria>
- Expert interface in resultsSlice.ts uses snake_case field names matching /api/explore API response
- resultsSlice has appendResults (extend array), isFetchingMore (boolean), setFetchingMore (setter)
- useExplore hook exposes loadNextPage that safely fetches next cursor page and appends results
- react-virtuoso and motion are in frontend/package.json
- npm run build passes with zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/17-expert-grid-cards/17-01-SUMMARY.md`
</output>
