---
phase: 48-admin-features-and-industry-tags
plan: 04
type: execute
wave: 2
depends_on:
  - 48-01
  - 48-02
files_modified:
  - app/models.py
  - app/main.py
  - app/routers/admin.py
  - app/routers/explore.py
  - app/services/explorer.py
  - frontend/src/constants/industryTags.ts
  - frontend/src/store/filterSlice.ts
  - frontend/src/store/index.ts
  - frontend/src/hooks/useExplore.ts
  - frontend/src/components/sidebar/TagCloud.tsx
  - frontend/src/components/sidebar/FilterSidebar.tsx
  - frontend/src/components/marketplace/MobileInlineFilters.tsx
autonomous: true
requirements:
  - DISC-01
  - DISC-02
  - DISC-03

must_haves:
  truths:
    - "Industry tags (Finance, Technology, Healthcare, etc.) are stored as a JSON array on each expert in the database"
    - "Industry tags are auto-assigned from job title, bio, and company text via keyword matching"
    - "Industry tags appear as a separate labeled section in the tag cloud, visually distinct from domain tags"
    - "User can select industry tags to filter experts independently of domain tag filters"
    - "Industry tag filter state is persisted across page reloads via Zustand persist"
    - "Existing domain tag filtering continues to work unchanged"
  artifacts:
    - path: "app/models.py"
      provides: "Expert.industry_tags column (Text, nullable)"
      contains: "industry_tags"
    - path: "app/main.py"
      provides: "Idempotent ALTER TABLE migration for industry_tags column"
      contains: "industry_tags"
    - path: "app/routers/admin.py"
      provides: "INDUSTRY_KEYWORDS dict, _auto_industry_tags function, industry_tags in serialization"
      contains: "_auto_industry_tags"
    - path: "app/services/explorer.py"
      provides: "industry_tags filter parameter in run_explore()"
      contains: "industry_tags"
    - path: "app/routers/explore.py"
      provides: "industry_tags query parameter on GET /api/explore"
      contains: "industry_tags"
    - path: "frontend/src/constants/industryTags.ts"
      provides: "INDUSTRY_TAGS constant array"
      contains: "INDUSTRY_TAGS"
    - path: "frontend/src/store/filterSlice.ts"
      provides: "industryTags state, toggleIndustryTag action, resetIndustryTags action"
      contains: "industryTags"
    - path: "frontend/src/store/index.ts"
      provides: "industryTags in partialize, version bump to 2, migrate function"
      contains: "industryTags"
    - path: "frontend/src/hooks/useExplore.ts"
      provides: "industry_tags param passed to /api/explore"
      contains: "industry_tags"
    - path: "frontend/src/components/sidebar/TagCloud.tsx"
      provides: "Industry tags section with label"
      contains: "Industry"
  key_links:
    - from: "frontend/src/hooks/useExplore.ts"
      to: "/api/explore"
      via: "industry_tags query param"
      pattern: "industry_tags"
    - from: "frontend/src/components/sidebar/TagCloud.tsx"
      to: "frontend/src/store/filterSlice.ts"
      via: "toggleIndustryTag action"
      pattern: "toggleIndustryTag"
    - from: "app/services/explorer.py"
      to: "app/models.py"
      via: "Expert.industry_tags.like filter"
      pattern: "industry_tags\\.like"
    - from: "app/main.py"
      to: "app/models.py"
      via: "ALTER TABLE migration"
      pattern: "ALTER TABLE experts ADD COLUMN industry_tags"
---

<objective>
Add industry-level tags (Finance, Healthcare, Technology, etc.) as a separate taxonomy — database column, auto-assign logic, backend filter, frontend store, tag cloud section, and explore filter integration.

Purpose: DISC-01/02/03 require industry tags alongside domain tags for multi-dimensional expert discovery. Industry tags describe WHERE experts work (verticals), distinct from domain tags describing WHAT they do (skills).
Output: Full vertical slice from DB schema through API to UI filter.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/48-admin-features-and-industry-tags/48-01-SUMMARY.md
@.planning/phases/48-admin-features-and-industry-tags/48-02-SUMMARY.md
@app/models.py
@app/main.py
@app/routers/admin.py
@app/routers/explore.py
@app/services/explorer.py
@frontend/src/store/filterSlice.ts
@frontend/src/store/index.ts
@frontend/src/hooks/useExplore.ts
@frontend/src/components/sidebar/TagCloud.tsx
@frontend/src/components/sidebar/FilterSidebar.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add industry_tags DB column, auto-assign logic, and backend filter</name>
  <files>app/models.py, app/main.py, app/routers/admin.py, app/routers/explore.py, app/services/explorer.py</files>
  <action>
**1. `app/models.py` — Add industry_tags column to Expert:**

Add to the Expert class:
```python
industry_tags: Mapped[str | None] = mapped_column(Text, nullable=True)
```
This stores a JSON array string like `'["Finance", "Technology"]'` or null.

**2. `app/main.py` — Add idempotent startup migration:**

In the existing lifespan function, add an idempotent ALTER TABLE migration for the new column. Follow the exact pattern used for `photo_url` (Phase 36) and `email` purge (Phase 41):
```python
try:
    _conn.execute(_text("ALTER TABLE experts ADD COLUMN industry_tags TEXT"))
    log.info("startup: experts.industry_tags column added")
except Exception:
    pass  # Column already exists — idempotent
```

Place this alongside the existing migrations in the lifespan startup block.

**3. `app/routers/admin.py` — Add industry tag constants and auto-assign function:**

Add a new constant `INDUSTRY_KEYWORDS` dict (similar pattern to existing `CATEGORY_KEYWORDS`):
```python
INDUSTRY_KEYWORDS = {
    "Finance":     ["finance", "cfo", "accountant", "banker", "investment", "fintech", "trading", "corporate finance", "private equity", "venture capital"],
    "Technology":  ["engineer", "developer", "cto", "software", "data", "ai", "ml", "saas", "product", "web", "devops", "tech"],
    "Healthcare":  ["health", "medical", "doctor", "pharma", "wellness", "biotech"],
    "Real Estate": ["real estate", "property", "construction", "renovation", "architecture"],
    "Marketing":   ["marketing", "cmo", "brand", "social media", "growth", "seo", "content", "digital marketing"],
    "Sales":       ["sales", "revenue", "business development", "account management"],
    "Operations":  ["operations", "coo", "supply chain", "logistics", "procurement", "process"],
    "Legal":       ["legal", "lawyer", "attorney", "compliance", "gdpr", "regulatory"],
    "HR":          ["hr", "human resources", "recruiter", "talent", "coaching", "people"],
    "Strategy":    ["strategy", "consulting", "advisor", "entrepreneur", "founder", "ceo", "board"],
    "Sports":      ["sport", "football", "fitness", "athlete", "coach", "esports"],
    "Media":       ["media", "journalism", "publishing", "entertainment", "film", "music"],
}
```

Add an `_auto_industry_tags` function:
```python
def _auto_industry_tags(job_title: str, bio: str = "", company: str = "") -> list[str]:
    """Return up to 3 matching industry tags from job title + bio + company."""
    text = f"{job_title} {bio} {company}".lower()
    matched = []
    for industry, keywords in INDUSTRY_KEYWORDS.items():
        if any(kw in text for kw in keywords):
            matched.append(industry)
        if len(matched) == 3:
            break
    return matched
```

Update `_serialize_expert()` to include `industry_tags`:
```python
"industry_tags": json.loads(expert.industry_tags) if expert.industry_tags else [],
```

Update `_seed_experts_from_csv()`: after setting expert fields, auto-assign industry tags:
```python
expert.industry_tags = json.dumps(_auto_industry_tags(expert.job_title or "", expert.bio or "", expert.company or ""))
```

Update `import_experts_csv()` to also auto-assign industry tags for each imported expert.

Add an admin endpoint `POST /api/admin/experts/assign-industry-tags` that batch-assigns industry tags to ALL existing experts (one-time bootstrap). This iterates all experts, calls `_auto_industry_tags`, and updates `industry_tags` column. Returns count of updated experts. This is needed because existing experts in the DB do not have industry_tags yet.

**4. `app/routers/explore.py` — Add industry_tags query parameter:**

Add to the `explore()` function signature:
```python
industry_tags: str = Query(default=""),  # comma-separated industry tags
```

Parse it:
```python
industry_tag_list = [t.strip() for t in industry_tags.split(",") if t.strip()]
```

Pass to `run_explore()`:
```python
run_explore(
    query=query,
    rate_min=rate_min,
    rate_max=rate_max,
    tags=tag_list,
    industry_tags=industry_tag_list,  # NEW
    limit=limit,
    cursor=cursor,
    db=db,
    app_state=request.app.state,
)
```

**5. `app/services/explorer.py` — Add industry_tags filter to run_explore():**

Update `run_explore()` signature to accept `industry_tags: list[str] = []` parameter (with default empty list for backwards compatibility).

Add industry tag filtering in the pre-filter stage (Stage 1), after existing tag filters:
```python
for itag in industry_tags:
    stmt = stmt.where(Expert.industry_tags.like(f'%"{itag}"%'))
```

This uses AND logic across industry tags (same pattern as domain tags).

CRITICAL: Also update `_explore_for_lab()` in `admin.py` to pass `industry_tags=[]` to `run_explore()`. Failure to do this causes a `TypeError: run_explore() missing argument` — see Pitfall 3 in research.
  </action>
  <verify>
    <automated>cd /Users/sebastianhamers/Documents/TCS && python -c "
from app.models import Expert
assert hasattr(Expert, 'industry_tags'), 'Missing industry_tags column'
from app.routers.admin import _auto_industry_tags, INDUSTRY_KEYWORDS
result = _auto_industry_tags('CTO and software engineer', '', 'FinTech startup')
assert 'Technology' in result, f'Expected Technology in {result}'
print(f'Auto-tag test: {result}')
print('PASS: backend industry tags')
"</automated>
  </verify>
  <done>Expert model has industry_tags column with idempotent migration. Auto-assign function tags experts from job title/bio/company keywords. Explore endpoint accepts industry_tags query param for independent filtering. Both explore.py and admin.py _explore_for_lab call sites pass industry_tags.</done>
</task>

<task type="auto">
  <name>Task 2: Add industry tags to Zustand store, useExplore hook, TagCloud, and filter UI</name>
  <files>frontend/src/constants/industryTags.ts, frontend/src/store/filterSlice.ts, frontend/src/store/index.ts, frontend/src/hooks/useExplore.ts, frontend/src/components/sidebar/TagCloud.tsx, frontend/src/components/sidebar/FilterSidebar.tsx, frontend/src/components/marketplace/MobileInlineFilters.tsx</files>
  <action>
**1. `frontend/src/constants/industryTags.ts` (NEW FILE):**

Create a new constants file:
```typescript
export const INDUSTRY_TAGS = [
  'Finance', 'Technology', 'Healthcare', 'Real Estate', 'Marketing',
  'Sales', 'Operations', 'Legal', 'HR', 'Strategy', 'Sports', 'Media',
] as const

export type IndustryTag = typeof INDUSTRY_TAGS[number]
```

**2. `frontend/src/store/filterSlice.ts` — Extend FilterSlice:**

Per STATE.md locked decision: "separate `industryTags: string[]` field in filterSlice, never share array with domain tags."

Add to `FilterSlice` interface:
```typescript
industryTags: string[]
toggleIndustryTag: (tag: string) => void
resetIndustryTags: () => void
```

Add to `filterDefaults`:
```typescript
industryTags: [] as string[],
```

Add to `createFilterSlice` body:
```typescript
toggleIndustryTag: (tag) => {
  get().setSageMode(false)
  set((state) => ({
    industryTags: state.industryTags.includes(tag)
      ? state.industryTags.filter((t) => t !== tag)
      : [...state.industryTags, tag],
  }))
},
resetIndustryTags: () => set({ industryTags: [] }),
```

IMPORTANT: Also update `resetFilters()` to include `industryTags: []` in the reset spread. Since `filterDefaults` now includes `industryTags: []`, this is automatic via `set({ ...filterDefaults })`.

**3. `frontend/src/store/index.ts` — Persist and migrate:**

Add `industryTags` to `partialize`:
```typescript
partialize: (state) => ({
  query:     state.query,
  rateMin:   state.rateMin,
  rateMax:   state.rateMax,
  tags:      state.tags,
  industryTags: state.industryTags,  // NEW
  sortBy:    state.sortBy,
  sortOrder: state.sortOrder,
  viewMode:  state.viewMode,
}),
```

Bump version from 1 to 2 and add migrate function:
```typescript
version: 2,
migrate: (persistedState: unknown, version: number) => {
  if (version === 1) {
    return { ...(persistedState as object), industryTags: [] }
  }
  return persistedState as object
},
```

Add `industryTags`, `toggleIndustryTag`, `resetIndustryTags` to the `useFilterSlice` hook selector object.

**4. `frontend/src/hooks/useExplore.ts` — Pass industry_tags to API:**

Add `industryTags` selector:
```typescript
const industryTags = useExplorerStore((s) => s.industryTags)
```

In the initial fetch `useEffect`, add to the URLSearchParams:
```typescript
if (industryTags.length > 0) {
  params.set('industry_tags', industryTags.join(','))
}
```

Add `industryTags` to the useEffect dependency array (after `tags`).

In `loadNextPage`, add the same param:
```typescript
if (industryTags.length > 0) {
  params.set('industry_tags', industryTags.join(','))
}
```

Add `industryTags` to loadNextPage's `useCallback` dependency array.

**5. `frontend/src/components/sidebar/TagCloud.tsx` — Add industry section:**

Import `INDUSTRY_TAGS` from `../../constants/industryTags`.

Add selectors:
```typescript
const toggleIndustryTag = useExplorerStore((s) => s.toggleIndustryTag)
const industryTags = useExplorerStore((s) => s.industryTags)
```

Restructure the return JSX to have two labeled sections:

```tsx
return (
  <LayoutGroup>
    <div className="flex flex-col gap-4">
      {/* Domain tags — existing section */}
      <div>
        <p className="text-xs font-medium text-gray-400 uppercase tracking-wider mb-2">Domain</p>
        <div
          className="flex flex-wrap gap-2"
          onMouseMove={handleMouseMove}
          onMouseLeave={handleMouseLeave}
          role="group"
          aria-label="Domain tags"
        >
          {sortedTags.map((tag) => (
            <TagPill
              key={tag}
              tag={tag}
              isSelected={tags.includes(tag)}
              mouseX={mouseX}
              mouseY={mouseY}
              onToggle={() => toggleTag(tag)}
            />
          ))}
        </div>
      </div>

      {/* Industry tags — new section */}
      <div>
        <p className="text-xs font-medium text-gray-400 uppercase tracking-wider mb-2">Industry</p>
        <div
          className="flex flex-wrap gap-2"
          onMouseMove={handleMouseMove}
          onMouseLeave={handleMouseLeave}
          role="group"
          aria-label="Industry tags"
        >
          {INDUSTRY_TAGS.map((tag) => (
            <TagPill
              key={`industry-${tag}`}
              tag={tag}
              isSelected={industryTags.includes(tag)}
              mouseX={mouseX}
              mouseY={mouseY}
              onToggle={() => toggleIndustryTag(tag)}
            />
          ))}
        </div>
      </div>
    </div>
  </LayoutGroup>
)
```

**6. `frontend/src/components/sidebar/FilterSidebar.tsx` — Update section labels if needed:**

If FilterSidebar has a label for the tag cloud section, keep it or update it to be a neutral label like "Tags" since the TagCloud now self-labels its sections. Inspect the file and ensure the industry tags section is visible in the sidebar.

**7. `frontend/src/components/marketplace/MobileInlineFilters.tsx` — Add industry tags:**

If this component has a tag picker section, extend it to include industry tags using the same `INDUSTRY_TAGS` constant and `toggleIndustryTag` action. Follow the same pattern as domain tags: list industry tags with toggle pills. Add an "Industry" label above the industry tag pills.
  </action>
  <verify>
    <automated>cd /Users/sebastianhamers/Documents/TCS && grep -q "industryTags" frontend/src/store/filterSlice.ts && grep -q "industryTags" frontend/src/store/index.ts && grep -q "industry_tags" frontend/src/hooks/useExplore.ts && grep -q "INDUSTRY_TAGS" frontend/src/components/sidebar/TagCloud.tsx && grep -q "INDUSTRY_TAGS" frontend/src/constants/industryTags.ts && echo "PASS"</automated>
    <manual>Visit explorer, verify two tag sections (Domain and Industry) appear in sidebar. Click an industry tag, verify experts filter. Refresh page, verify selection persists.</manual>
  </verify>
  <done>Industry tags appear as a separate labeled section in the TagCloud. Selecting an industry tag filters experts independently of domain tags. Selection persists via Zustand persist with version migration. Domain tag filtering continues unchanged.</done>
</task>

</tasks>

<verification>
- Expert.industry_tags column exists in DB (idempotent migration)
- _auto_industry_tags returns reasonable tags for test inputs
- GET /api/explore accepts industry_tags query param
- TagCloud shows two labeled sections: Domain and Industry
- Industry tag selection triggers expert filtering
- Zustand store version bumped to 2 with migration
- resetFilters() clears both tags and industryTags
- _explore_for_lab passes industry_tags=[] (no TypeError)
</verification>

<success_criteria>
Industry-level tags are stored on experts, auto-assigned from profile text, visible in the tag cloud as a separate section, and filterable independently of domain tags.
</success_criteria>

<output>
After completion, create `.planning/phases/48-admin-features-and-industry-tags/48-04-SUMMARY.md`
</output>
