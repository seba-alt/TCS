# Phase 50.1: Lead Click Tracking, Data Reset & Search Bar Visibility - Research

**Researched:** 2026-02-27
**Domain:** Admin analytics (lead-click attribution), data management, CSS/Tailwind search bar, expert name normalization
**Confidence:** HIGH

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Click Tracking Display:**
- Track clicks only from identified leads (users who provided their email)
- Two views in admin: a dedicated "Leads" tab AND click data on each expert's detail page
- Leads tab: grouped by lead email, each lead as a header with their clicked experts listed underneath
- Data per click event: lead email, expert full name (First Last), timestamp, search query that led to the click
- Expert detail view: show which leads clicked on that specific expert

**Data Reset for Launch:**
- Full wipe of conversations.db — conversations, lead data, search/analytics history
- Preserve expert data: metadata.json, experts.csv, FAISS index untouched
- One-time script/migration — run before launch, no ongoing admin button needed

**Search Bar Visibility:**
- Current issue: border is too subtle, blends in
- Make the search bar itself more visually prominent (not the results)
- No focus state changes — same look whether focused or not, just make the default state more visible

**Expert Name Display in Admin:**
- Admin views only (not the public chatbot)
- Replace usernames completely with "First Last" format
- No username shown anywhere in admin — full name only

### Claude's Discretion
- Search bar border treatment approach (solid border, accent color, shadow, or combo — whatever makes it pop)
- Click tracking table/list styling and layout details
- Reset script implementation approach

### Deferred Ideas (OUT OF SCOPE)
None — discussion stayed within phase scope
</user_constraints>

---

## Summary

Phase 50.1 has four distinct sub-tasks that each touch different parts of the codebase. The most architecturally significant is **lead click tracking**, which requires solving a session-email attribution problem: the existing `card_click` events in `user_events` are keyed by `session_id` (no email), while the email gate stores the user's email separately in `nltrStore` (Zustand, persisted as `tinrate-newsletter-v1` in localStorage). The solution is to store a new `lead_click` event type (or a DB table) that captures email at the moment of click — by reading `nltrStore.email` in the frontend at click time and sending it to a new backend endpoint.

The **data reset** backend endpoint already exists: `POST /api/admin/reset-data` at line 1899 of `app/routers/admin.py`. It truncates `conversations`, `email_leads`, `feedback`, `newsletter_subscribers`, and `user_events` tables while preserving `experts`, `admin_users`, and `settings`. The user wants a one-time script (not an ongoing admin button), so the deliverable is a simple Python CLI script that calls this endpoint or executes the deletions directly.

The **search bar** CSS fix is a single-file change to `frontend/src/components/Header.tsx` line 183: the current class `border border-slate-200` is replaced with a more prominent border. No logic changes.

The **expert name normalization** in admin is already mostly done: `ExpertsPage.tsx` already renders `{expert.first_name} {expert.last_name}` (not username) in the main table. The issue is `AdminMarketplacePage.tsx` displays `expert_id` (raw username) in the exposure table, and the `LeadClickTracking` feature (new in this phase) must also use full names.

**Primary recommendation:** Implement in three focused plans: (1) lead click tracking — new `LeadClick` DB model + backend endpoint + frontend hook + Leads tab expansion + expert detail sub-view, (2) search bar CSS fix + expert username cleanup in AdminMarketplacePage, (3) data reset script.

---

## Standard Stack

### Core (all in use — no new dependencies)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| FastAPI + SQLAlchemy | current | New `LeadClick` model + endpoint | Already in use; same migration pattern as prior phases |
| SQLite | current | `lead_clicks` table | Already at `$VAR_DIR/conversations.db` |
| React + Tailwind | current | Leads tab UI expansion + CSS fix | Already in use |
| `adminFetch` / `adminPost` | internal | Admin API calls | Already in `useAdminData.ts` |
| Zustand `nltrStore` | current | Read email from `state.email` at click time | `tinrate-newsletter-v1` key; email is persisted when user completes newsletter gate |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Python `requests` or direct SQLAlchemy | stdlib/current | One-time reset script | CLI script calls `SessionLocal()` directly — no HTTP needed |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| New `LeadClick` DB table | Annotate `user_events` with email | Separate table is cleaner; avoids schema-coupling `user_events` to lead identity; easier to query by email |
| New `lead_click` event type on `/api/events` | New `/api/lead-clicks` endpoint | New endpoint is simpler: no auth needed (public), receives `email + expert_id + query + timestamp`, writes to new table. No changes to existing events.py. |
| Frontend sends email on every card_click | Backend joins session→email | Frontend approach is simpler: email is available in `nltrStore` at click time; no session-to-email join infrastructure needed |

**Installation:** No new packages required.

---

## Architecture Patterns

### Recommended File Changes

```
Backend:
  app/models.py                           — ADD: LeadClick model
  app/main.py (lifespan)                  — auto-creates LeadClick table via create_all
  app/routers/admin.py                    — ADD: GET /lead-clicks (grouped by email) + GET /lead-clicks/by-expert/{username}
  scripts/reset_for_launch.py             — NEW: one-time reset script (DELETE FROM tables)

Frontend:
  frontend/src/components/marketplace/ExpertCard.tsx    — EXTEND: trackEvent sends email for leads
  frontend/src/admin/pages/LeadsPage.tsx                — EXTEND: click history in expanded row
  frontend/src/admin/pages/ExpertsPage.tsx              — EXTEND: add expert detail click panel
  frontend/src/admin/components/Header.tsx              — FIX: search bar border
  frontend/src/admin/pages/AdminMarketplacePage.tsx     — FIX: show "First Last" instead of expert_id
  frontend/src/admin/types.ts                           — ADD: LeadClickRow, LeadClicksResponse
  frontend/src/admin/hooks/useAdminData.ts              — ADD: useLeadClicks hook
```

### Pattern 1: LeadClick Model (new DB table)
**What:** A new SQLAlchemy model that stores email-keyed click events. Distinct from `user_events` which is session-keyed.
**When to use:** Any time a logged-in lead (identified email) clicks on an expert card.

```python
# app/models.py — add after UserEvent class:
class LeadClick(Base):
    """
    Records expert card clicks by identified leads (email-gated users).
    Distinct from user_events which uses anonymous session_id.
    Used by admin /lead-clicks endpoints for lead-level click attribution.
    """
    __tablename__ = "lead_clicks"

    id: Mapped[int] = mapped_column(primary_key=True, index=True)
    email: Mapped[str] = mapped_column(String(320), nullable=False, index=True)
    expert_username: Mapped[str] = mapped_column(String(100), nullable=False, index=True)
    search_query: Mapped[str] = mapped_column(Text, nullable=True)  # the query that surfaced this expert
    created_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, default=datetime.datetime.utcnow, nullable=False
    )
```

No Alembic needed — `Base.metadata.create_all()` in `app/main.py` lifespan creates it automatically on Railway startup.

### Pattern 2: Lead Click Capture Endpoint (public, no auth)
**What:** `POST /api/lead-clicks` — receives email + expert_username + search_query, writes to `lead_clicks` table. No auth required (same as `/api/events`).

```python
# app/routers/admin.py or a new app/routers/lead_clicks.py
# Recommended: add to app/main.py router registrations alongside events router

class LeadClickRequest(BaseModel):
    email: str = Field(..., min_length=1, max_length=320)
    expert_username: str = Field(..., min_length=1, max_length=100)
    search_query: str = Field(default="", max_length=2000)

@router.post("/api/lead-clicks", status_code=202)
def record_lead_click(body: LeadClickRequest, db: Session = Depends(get_db)):
    """Record a card click by an identified lead (email-gated user)."""
    record = LeadClick(
        email=body.email,
        expert_username=body.expert_username,
        search_query=body.search_query,
    )
    db.add(record)
    db.commit()
    return {"status": "accepted"}
```

### Pattern 3: Frontend Click Capture (extend ExpertCard)
**What:** When `handleCardClick` fires in `ExpertCard.tsx`, also check if the user is email-gated (has email in `nltrStore`). If yes, fire a second `POST /api/lead-clicks` with their email.
**When to use:** On every expert card click, after the existing `trackEvent('card_click', ...)` call.

```typescript
// frontend/src/components/marketplace/ExpertCard.tsx
import { useNltrStore } from '../../store/nltrStore'

function handleCardClick() {
  const storeState = useExplorerStore.getState()
  const nltrEmail = useNltrStore.getState().email  // null if not yet email-gated

  void trackEvent('card_click', {
    expert_id: expert.username,
    context,
    rank,
    active_filters: { query: storeState.query, ... },
  })

  // NEW: also fire lead-click if the user is email-identified
  if (nltrEmail) {
    void fetch(`${API_BASE}/api/lead-clicks`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      keepalive: true,
      body: JSON.stringify({
        email: nltrEmail,
        expert_username: expert.username,
        search_query: storeState.query,
      }),
    })
  }

  // ... rest of handleCardClick (onViewProfile)
}
```

**IMPORTANT:** `useNltrStore.getState()` (not the hook) must be used inside an event handler that is NOT called during render. This is already the pattern in ExpertCard for `useExplorerStore.getState()` — same approach.

### Pattern 4: Admin Lead-Clicks Endpoints (admin-auth required)
**What:** Two new endpoints on the admin router — grouped by email and by expert username — for the two admin views.

```python
# GET /api/admin/lead-clicks — grouped by email
@router.get("/lead-clicks")
def get_lead_clicks(db: Session = Depends(get_db)):
    """
    Return lead click events grouped by email.
    Response: {leads: [{email, clicks: [{expert_username, expert_name, search_query, created_at}]}]}
    """
    rows = db.scalars(
        select(LeadClick).order_by(LeadClick.created_at.desc())
    ).all()

    # Enrich with expert First Last name from Expert table
    leads: dict[str, list] = {}
    for row in rows:
        expert = db.scalar(select(Expert).where(Expert.username == row.expert_username))
        expert_name = f"{expert.first_name} {expert.last_name}" if expert else row.expert_username
        if row.email not in leads:
            leads[row.email] = []
        leads[row.email].append({
            "expert_username": row.expert_username,
            "expert_name": expert_name,
            "search_query": row.search_query,
            "created_at": row.created_at.isoformat(),
        })

    return {"leads": [{"email": email, "clicks": clicks} for email, clicks in leads.items()]}


# GET /api/admin/lead-clicks/by-expert/{username} — for expert detail view
@router.get("/lead-clicks/by-expert/{username}")
def get_lead_clicks_by_expert(username: str, db: Session = Depends(get_db)):
    """
    Return all lead click events for a specific expert.
    Response: {expert_username, clicks: [{email, search_query, created_at}]}
    """
    rows = db.scalars(
        select(LeadClick)
        .where(LeadClick.expert_username == username)
        .order_by(LeadClick.created_at.desc())
    ).all()
    return {
        "expert_username": username,
        "clicks": [
            {"email": r.email, "search_query": r.search_query, "created_at": r.created_at.isoformat()}
            for r in rows
        ],
    }
```

**Performance note:** For large datasets, the `get_lead_clicks` endpoint does N queries (one per click to enrich with expert name). Optimize by fetching all distinct usernames first and batch-loading Expert rows. For a launch-scale dataset (hundreds to low thousands of clicks), this is acceptable.

### Pattern 5: Expert Name Lookup (batch for lead-clicks endpoint)
**What:** Instead of N+1 queries in `get_lead_clicks`, pre-load a username→name dict.

```python
# Batch lookup pattern (already used in other admin.py endpoints):
all_usernames = {row.expert_username for row in rows}
experts_map = {
    e.username: f"{e.first_name} {e.last_name}"
    for e in db.scalars(select(Expert).where(Expert.username.in_(all_usernames))).all()
}
# Then: experts_map.get(row.expert_username, row.expert_username)
```

### Pattern 6: LeadsPage Expansion (click history section)
**What:** Extend the expanded row in `LeadsPage.tsx` to show click history when expanded, below the existing "Recent queries" section.

```tsx
// In LeadsPage.tsx, the expanded row already exists (lines 241-262).
// Add a second section fetched lazily when expanded:
// - On expand: adminFetch<LeadClicksByEmailResponse>(`/lead-clicks?email=${lead.email}`)
// - Show: "Expert Clicks" sub-section with expert name + timestamp + query pills

// New type needed in types.ts:
interface LeadClickEntry {
  expert_username: string
  expert_name: string
  search_query: string
  created_at: string
}

interface LeadClicksByLeadResponse {
  leads: { email: string; clicks: LeadClickEntry[] }[]
}
```

### Pattern 7: ExpertsPage Detail Panel (lead clicks for one expert)
**What:** The expert detail is not a separate route — show click data inline in the experts table as a collapsible row, similar to the leads table expansion pattern, or as a side panel.

Decision: follow the same "expandable row" pattern already used in `LeadsPage.tsx` and `SearchesTable.tsx`. Add an expand button per expert row that loads `/api/admin/lead-clicks/by-expert/{username}` and shows the email + timestamp list inline.

### Pattern 8: Data Reset Script
**What:** A Python script that connects to the DB via SQLAlchemy and deletes all rows from the transactional tables. Can be run locally or via Railway CLI (run as one-off task).

```python
# scripts/reset_for_launch.py
"""
One-time pre-launch data reset.
Deletes all conversations, leads, analytics, feedback, and user events.
Preserves: experts, admin_users, settings.

Usage:
  python scripts/reset_for_launch.py            # dry-run (shows counts)
  python scripts/reset_for_launch.py --confirm  # actually deletes
"""
import sys
from sqlalchemy import select, func
from app.database import SessionLocal
from app.models import Conversation, EmailLead, Feedback, NewsletterSubscriber, UserEvent, LeadClick

TABLES_TO_WIPE = [Feedback, Conversation, EmailLead, NewsletterSubscriber, UserEvent, LeadClick]

def main():
    confirm = "--confirm" in sys.argv
    db = SessionLocal()
    try:
        for model in TABLES_TO_WIPE:
            count = db.query(model).count()
            print(f"  {model.__tablename__}: {count} rows {'→ DELETED' if confirm else '(dry run)'}")
            if confirm:
                db.query(model).delete()
        if confirm:
            db.commit()
            print("Done. Database cleared for launch.")
        else:
            print("\nRun with --confirm to actually delete.")
    finally:
        db.close()

if __name__ == "__main__":
    main()
```

**Alternative:** The user could also just call `POST /api/admin/reset-data` from the Railway console or via curl. The backend endpoint already exists and works. The script provides a dry-run preview which the user may find reassuring before launch.

### Pattern 9: Search Bar Border Fix
**What:** Single CSS change in `Header.tsx` line 183. Current: `border border-slate-200`. Replace with a more visible treatment.
**Recommendation (Claude's Discretion):** Use `border-2 border-slate-300 shadow-sm` — a slightly thicker border (slate-300 is 20% darker than slate-200 on white backgrounds) plus a subtle drop shadow. This makes it "pop" without changing the color palette. No focus-state change (as per locked decision).

```tsx
// frontend/src/components/Header.tsx — line 183, className of the <input>:
// BEFORE:
"w-full pl-14 pr-8 py-2.5 rounded-xl text-sm bg-white border border-slate-200 focus:outline-none focus:ring-2 focus:ring-brand-purple/20 focus:border-brand-purple/40 transition-colors"

// AFTER (Claude's discretion — solid border + shadow):
"w-full pl-14 pr-8 py-2.5 rounded-xl text-sm bg-white border-2 border-slate-300 shadow-sm focus:outline-none focus:ring-2 focus:ring-brand-purple/20 focus:border-brand-purple/40 transition-colors"
```

### Pattern 10: Admin Username → Full Name (AdminMarketplacePage)
**What:** `AdminMarketplacePage.tsx` line 390 currently renders `row.expert_id` (the raw username from `user_events` payload). Replace with a lookup for the full name.

The `ExposureRow` type already exists in `types.ts` with `expert_id: string`. The backend exposure endpoint (`/api/admin/events/exposure`) returns `expert_id` as the raw username string. Fix at the backend: enrich the response with `expert_name` by joining Expert table. Or fix at frontend: use the `useAdminExperts()` data to build a username→name lookup map.

**Recommendation:** Fix at the backend — enrich `ExposureRow` with `expert_name: string | null`. This keeps the frontend simple and follows the pattern of enriching at the source.

```python
# admin.py get_exposure_data() — the existing query returns expert_id (username).
# Add: after the SELECT query, batch-lookup Expert table:
all_ids = {r.expert_id for r in rows if r.expert_id}
name_map = {
    e.username: f"{e.first_name} {e.last_name}"
    for e in db.scalars(select(Expert).where(Expert.username.in_(all_ids))).all()
}
return {
    "data_since": data_since,
    "exposure": [
        {
            "expert_id": r.expert_id,
            "expert_name": name_map.get(r.expert_id),  # NEW
            "total_clicks": r.total_clicks,
            "grid_clicks": r.grid_clicks,
            "sage_clicks": r.sage_clicks,
        }
        for r in rows
    ],
}
```

Frontend: update `ExposureRow` type and the table cell to show `row.expert_name ?? row.expert_id`.

### Anti-Patterns to Avoid
- **Using `useNltrStore()` hook inside the event handler:** `useExplorerStore.getState()` is already the established pattern in ExpertCard for reading store state inside a non-render callback. Apply the same: `useNltrStore.getState().email` — NOT the hook.
- **Adding email to the existing `user_events`/`trackEvent` flow:** The `user_events` table schema (`session_id + event_type + payload`) and the `EventRequest` Pydantic model don't include email. Avoid modifying the existing events pipeline; use a separate endpoint and table.
- **N+1 query in lead-clicks endpoint:** Always batch-load expert names using `Expert.username.in_(all_usernames)` — do not query per row.
- **Deleting the `expert_id` field from `ExposureRow`:** The ID is still needed as a unique key and for filtering. Add `expert_name` alongside it, don't replace.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Email attribution at click time | Session→email join table | Read `useNltrStore.getState().email` in ExpertCard | Email is already stored in Zustand at gate time; no join needed |
| DB table creation | Alembic migration | `Base.metadata.create_all()` (startup) | Already the project pattern; creates new tables automatically |
| Reset script HTTP call | New admin endpoint | Direct SQLAlchemy in script OR existing `POST /api/admin/reset-data` | Backend endpoint already exists with exact behavior needed |
| Expert name lookup | Separate name endpoint | Batch `Expert.username.in_([...])` query | Standard SQLAlchemy IN query; same pattern used in `domain-map` endpoint |

**Key insight:** The email-to-click attribution problem that was documented as "blocked" in Phase 48 (LEAD-01 open question) is now solvable without any backend session tracking changes — the email is available client-side in `nltrStore` at the exact moment of click.

---

## Common Pitfalls

### Pitfall 1: `useNltrStore` vs `useNltrStore.getState()` inside event handler
**What goes wrong:** Calling the Zustand hook `useNltrStore()` inside a non-component callback (like `handleCardClick`) causes a React rules-of-hooks violation.
**Why it happens:** `handleCardClick` is defined inside a functional component but is not a hook itself; calling hooks inside it violates the rules of hooks.
**How to avoid:** Use the static `useNltrStore.getState()` — already the pattern for `useExplorerStore.getState()` in the same file (ExpertCard.tsx lines 49, 68).
**Warning signs:** ESLint "rules of hooks" error on `useNltrStore()` inside `handleCardClick`.

### Pitfall 2: `LeadClick` table not created on Railway on first deploy
**What goes wrong:** `LeadClick` model is added to `models.py` but Railway's existing DB already has all other tables; `create_all` only creates NEW tables, which is the correct behavior — so this is actually safe.
**Why it happens:** Misunderstanding of `create_all` semantics. It is idempotent and adds missing tables without touching existing ones.
**How to avoid:** Just add the model — no migration script needed. Confirm with the existing comment in `models.py`: "Auto-created by Base.metadata.create_all at startup — no migration needed."
**Warning signs:** None expected. If `lead_clicks` table doesn't exist after deploy, check that `LeadClick` is imported in `app/models.py` and that `import app.models` fires in `main.py` before `Base.metadata.create_all()`.

### Pitfall 3: `reset_for_launch.py` must also wipe `lead_clicks`
**What goes wrong:** The existing `POST /api/admin/reset-data` endpoint (admin.py line 1910) does NOT include `LeadClick` because that model doesn't exist yet. The reset script must be written AFTER `LeadClick` is added, and must include it in `TABLES_TO_WIPE`.
**Why it happens:** New model added in same phase as reset script.
**How to avoid:** Reset script imports `LeadClick` from `app.models`. If `LeadClick` is not yet in models at script execution time, it will error. Write/run after models.py is updated.

### Pitfall 4: Expert detail click view needs lazy loading
**What goes wrong:** Loading all lead-click data for every expert on `ExpertsPage.tsx` initial mount would fire 530+ API calls (one per expert).
**Why it happens:** Eager fetching without lazy/on-demand loading.
**How to avoid:** Only fetch `/api/admin/lead-clicks/by-expert/{username}` when the user expands a specific expert row (on-demand, same pattern as `LeadsPage.tsx` expanded row). Never fetch on mount.

### Pitfall 5: `ExposureRow.expert_name` may be null for deleted experts
**What goes wrong:** If an expert was deleted from the DB but still has `user_events` entries, the batch lookup returns no name.
**Why it happens:** `user_events` retains historical records; `Expert` table only has current experts.
**How to avoid:** Use `expert_name: name_map.get(r.expert_id)` (returns `None` if not found); frontend falls back to `row.expert_name ?? row.expert_id` (shows username as fallback).

### Pitfall 6: `nltrStore.email` is null for non-gated users
**What goes wrong:** The lead-click fires with `email: null`, creating blank-email rows in `lead_clicks`.
**Why it happens:** Users who haven't gone through the newsletter gate have `nltrStore.email === null`.
**How to avoid:** Guard: `if (nltrEmail) { /* fire lead-click */ }` — already in the Pattern 3 example above.

---

## Code Examples

Verified patterns from existing codebase:

### Email Available in Zustand (HIGH confidence)
```typescript
// Source: frontend/src/store/nltrStore.ts — persisted in localStorage as 'tinrate-newsletter-v1'
// nltrStore.email is set by setSubscribed(email) when user completes newsletter gate
const nltrEmail = useNltrStore.getState().email  // string | null
```

### Static Store Read in Event Handler (HIGH confidence)
```typescript
// Source: frontend/src/components/marketplace/ExpertCard.tsx lines 49, 68
// Established pattern — already used twice in ExpertCard for useExplorerStore.getState()
const storeState = useExplorerStore.getState()
void trackEvent('card_click', { ... storeState.query ... })
```

### Backend Batch Expert Name Lookup (HIGH confidence)
```python
# Source: admin.py domain-map endpoint pattern (line 921+)
# Batch IN query already used in codebase — avoids N+1
name_map = {
    e.username: f"{e.first_name} {e.last_name}"
    for e in db.scalars(
        select(Expert).where(Expert.username.in_(all_usernames))
    ).all()
}
```

### Lazy Expanded Row Fetch (HIGH confidence)
```tsx
// Source: LeadsPage.tsx — expanded row fetches data on demand (not on mount)
// Same pattern to use for expert detail click view:
const [expandedUsername, setExpandedUsername] = useState<string | null>(null)
const [clickData, setClickData] = useState<Record<string, LeadClickEntry[]>>({})

async function handleExpandExpert(username: string) {
  if (expandedUsername === username) {
    setExpandedUsername(null)
    return
  }
  setExpandedUsername(username)
  if (!clickData[username]) {
    const data = await adminFetch<{ clicks: LeadClickEntry[] }>(
      `/lead-clicks/by-expert/${username}`
    )
    setClickData(prev => ({ ...prev, [username]: data.clicks }))
  }
}
```

### Search Bar Current State (HIGH confidence)
```tsx
// Source: frontend/src/components/Header.tsx line 183
// Current (too subtle):
className="w-full pl-14 pr-8 py-2.5 rounded-xl text-sm bg-white border border-slate-200 focus:outline-none focus:ring-2 focus:ring-brand-purple/20 focus:border-brand-purple/40 transition-colors"
// Proposed fix (Claude's discretion):
className="w-full pl-14 pr-8 py-2.5 rounded-xl text-sm bg-white border-2 border-slate-300 shadow-sm focus:outline-none focus:ring-2 focus:ring-brand-purple/20 focus:border-brand-purple/40 transition-colors"
```

### Existing Reset Endpoint (HIGH confidence)
```python
# Source: app/routers/admin.py lines 1897-1916
# Already implemented — truncates 5 tables, preserves experts/admin_users/settings
@router.post("/reset-data")
def reset_data(db: Session = Depends(get_db)):
    counts = {}
    for model in [Feedback, Conversation, EmailLead, NewsletterSubscriber, UserEvent]:
        count = db.query(model).count()
        db.query(model).delete()
        counts[model.__tablename__] = count
    db.commit()
    return {"ok": True, "deleted": counts}
# NOTE: LeadClick is NOT in this list yet (model doesn't exist until this phase).
# The reset script for launch must add LeadClick to the wipe list.
```

---

## Current Codebase State (verified)

### What Exists
- `POST /api/admin/reset-data` — fully implemented, wipes 5 tables (lines 1897-1916 of admin.py)
- `ExpertCard.tsx` already calls `useExplorerStore.getState()` in event handler — exact pattern needed for nltrStore
- `LeadsPage.tsx` has expandable rows — same pattern for click history extension
- `ExpertsPage.tsx` already renders `{expert.first_name} {expert.last_name}` (not username) in the main table
- `AdminMarketplacePage.tsx` line 390 renders `row.expert_id` (username) — this is the one place to fix
- `nltrStore.email` is `string | null`, persisted in localStorage, accessible via `useNltrStore.getState().email`
- `user_events` table stores `card_click` by `session_id` — NOT by email (confirmed)

### What Does NOT Exist (must be built)
- `LeadClick` DB model and `lead_clicks` table
- `POST /api/lead-clicks` endpoint (public, no auth)
- `GET /api/admin/lead-clicks` (admin, grouped by email)
- `GET /api/admin/lead-clicks/by-expert/{username}` (admin, for expert detail)
- Click capture logic in `ExpertCard.tsx`
- Click history in `LeadsPage.tsx` expanded row
- Expert detail click panel in `ExpertsPage.tsx`
- `scripts/reset_for_launch.py`
- `LeadClickRow` / `LeadClicksResponse` types in `admin/types.ts`
- `useLeadClicks` hook (or `adminFetch` inline calls) in `useAdminData.ts`

### Admin Name Display Audit
| Location | Current | Fix Needed |
|----------|---------|------------|
| `ExpertsPage.tsx` main table | `{expert.first_name} {expert.last_name}` | None — already correct |
| `AdminMarketplacePage.tsx` exposure table | `row.expert_id` (username) | Yes — add `expert_name` to ExposureRow |
| `ExposureRow` type | `expert_id: string` | Add `expert_name?: string` |
| Backend `/api/admin/events/exposure` | returns `expert_id` only | Enrich with `expert_name` via batch join |
| New lead-click admin views (this phase) | new — must use full names | Design with `expert_name` from start |

---

## State of the Art

| Old Approach | Current Approach | Impact on This Phase |
|--------------|------------------|----------------------|
| Session-only click tracking (no email attribution) | Lead click tracking via nltrStore.email at click time | LEAD-01 (prior open question) is now solvable client-side |
| One-time reset via manual SQL | Python script with dry-run + admin endpoint | Reset script reuses existing endpoint logic |
| `expert_id` (username) shown in exposure table | `expert_name` (First Last) shown | AdminMarketplacePage.tsx + ExposureRow enrichment |

---

## Open Questions

1. **Should `/api/lead-clicks` require authentication?**
   - What we know: `/api/events` does NOT require auth (fire-and-forget from browser); but it stores no PII. `/api/lead-clicks` stores email addresses.
   - What's unclear: Whether to treat it like `/api/events` (public) or like admin endpoints (auth required).
   - Recommendation: No auth — same as `/api/events`. The email is submitted by the user themselves (they are the PII owner). Rate limiting via Railway is the mitigation. Adding auth would require passing the admin token from the public marketplace page, which is wrong architecture.

2. **How many lead clicks to show in the Leads tab expanded view?**
   - What we know: The expanded row currently shows "Recent queries" (3 distinct queries). Same pattern applies.
   - What's unclear: Show ALL clicks or paginate/truncate?
   - Recommendation: Show all clicks (no pagination) with newest-first ordering. Lead click volume will be low at launch. Add a "Show less" collapse if > 10 clicks.

3. **Should the expert detail click view be inside ExpertsPage or a separate route?**
   - What we know: CONTEXT.md says "expert detail view" but does not specify a separate page.
   - What's unclear: Whether user expects a drill-down page or an inline panel.
   - Recommendation: Inline expandable row in ExpertsPage (same pattern as LeadsPage). No new route needed. This is the simplest implementation and consistent with existing admin UX patterns.

---

## Sources

### Primary (HIGH confidence)
- `/Users/sebastianhamers/Documents/TCS/app/models.py` — all DB models verified; `LeadClick` does not exist; `UserEvent` confirmed session-only
- `/Users/sebastianhamers/Documents/TCS/app/routers/admin.py` lines 1897-1916 — `reset_data` endpoint fully implemented
- `/Users/sebastianhamers/Documents/TCS/app/routers/events.py` — `EventRequest` schema confirmed (no email field)
- `/Users/sebastianhamers/Documents/TCS/frontend/src/components/marketplace/ExpertCard.tsx` — `useExplorerStore.getState()` pattern confirmed lines 49, 68
- `/Users/sebastianhamers/Documents/TCS/frontend/src/store/nltrStore.ts` — `email: string | null` persisted in localStorage
- `/Users/sebastianhamers/Documents/TCS/frontend/src/pages/MarketplacePage.tsx` lines 39-43 — legacy unlock check via `tcs_gate_email` / `tcs_email_unlocked` localStorage keys
- `/Users/sebastianhamers/Documents/TCS/frontend/src/components/Header.tsx` line 183 — current search bar class `border border-slate-200`
- `/Users/sebastianhamers/Documents/TCS/frontend/src/admin/pages/AdminMarketplacePage.tsx` line 390 — `row.expert_id` raw display confirmed
- `/Users/sebastianhamers/Documents/TCS/frontend/src/admin/pages/ExpertsPage.tsx` line 401-402 — `{expert.first_name} {expert.last_name}` already in use
- `/Users/sebastianhamers/Documents/TCS/frontend/src/admin/pages/LeadsPage.tsx` — expanded row pattern confirmed
- `/Users/sebastianhamers/Documents/TCS/frontend/src/admin/pages/OverviewPage.tsx` — `adminFetch` inline pattern in `RecentLeadsCard` / `RecentSearchesCard`
- `/Users/sebastianhamers/Documents/TCS/frontend/src/admin/hooks/useAdminData.ts` — `adminFetch`, `adminPost` utilities
- `/Users/sebastianhamers/Documents/TCS/frontend/src/admin/types.ts` — all existing type shapes; `LeadRow`, `ExposureRow` confirmed

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — no new libraries; all patterns traced to existing source files
- Architecture: HIGH — email attribution approach verified against actual nltrStore code; reset endpoint verified as already implemented
- Pitfalls: HIGH — derived from direct inspection of ExpertCard event handler pattern and existing table schemas

**Research date:** 2026-02-27
**Valid until:** 2026-03-29 (stable codebase, no fast-moving external dependencies)
