---
phase: 50.1-lead-click-tracking-data-reset-search-visibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/models.py
  - app/routers/admin.py
  - frontend/src/components/marketplace/ExpertCard.tsx
  - frontend/src/admin/types.ts
autonomous: true
requirements:
  - 50.1-LEAD-TRACK
  - 50.1-DATA-RESET

must_haves:
  truths:
    - "Lead card clicks by email-identified users are stored in a dedicated lead_clicks table"
    - "POST /api/lead-clicks accepts email + expert_username + search_query and returns 202"
    - "GET /api/admin/lead-clicks returns clicks grouped by email with expert full names"
    - "GET /api/admin/lead-clicks/by-expert/{username} returns clicks for a specific expert"
    - "ExpertCard sends a lead-click POST when the user has an email in nltrStore"
    - "ExpertCard does NOT send a lead-click when the user has no email"
    - "POST /api/admin/reset-data also wipes the lead_clicks table"
  artifacts:
    - path: "app/models.py"
      provides: "LeadClick SQLAlchemy model"
      contains: "class LeadClick"
    - path: "app/routers/admin.py"
      provides: "Lead-click admin endpoints + reset-data LeadClick inclusion"
      contains: "lead-clicks"
    - path: "frontend/src/components/marketplace/ExpertCard.tsx"
      provides: "Lead-click capture on card click"
      contains: "lead-clicks"
    - path: "frontend/src/admin/types.ts"
      provides: "LeadClick TypeScript types"
      contains: "LeadClickEntry"
  key_links:
    - from: "frontend/src/components/marketplace/ExpertCard.tsx"
      to: "/api/lead-clicks"
      via: "fetch POST on card click when nltrStore.email exists"
      pattern: "fetch.*lead-clicks"
    - from: "app/routers/admin.py"
      to: "app/models.py LeadClick"
      via: "SQLAlchemy query in admin endpoints"
      pattern: "select\\(LeadClick\\)"
---

<objective>
Build the full lead-click tracking data pipeline: database model, public capture endpoint, admin query endpoints, and frontend click capture in ExpertCard.

Purpose: Enable admin visibility into which identified leads (email-gated users) clicked on which experts, with the search query that surfaced each expert.

Output: LeadClick model in DB, POST /api/lead-clicks public endpoint, GET /api/admin/lead-clicks (grouped by email), GET /api/admin/lead-clicks/by-expert/{username}, frontend capture in ExpertCard, and lead_clicks included in reset-data wipe.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/milestones/v4.0-phases/50.1-lead-click-tracking-data-reset-search-visibility/50.1-CONTEXT.md
@.planning/milestones/v4.0-phases/50.1-lead-click-tracking-data-reset-search-visibility/50.1-RESEARCH.md
@app/models.py
@app/routers/admin.py
@app/routers/events.py
@app/main.py
@frontend/src/components/marketplace/ExpertCard.tsx
@frontend/src/store/nltrStore.ts
@frontend/src/admin/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LeadClick model + public capture endpoint + admin query endpoints</name>
  <files>app/models.py, app/routers/admin.py</files>
  <action>
**1. Add LeadClick model to app/models.py** (after the UserEvent class):

```python
class LeadClick(Base):
    """
    Records expert card clicks by identified leads (email-gated users).
    Distinct from user_events which uses anonymous session_id.
    Used by admin /lead-clicks endpoints for lead-level click attribution.
    Auto-created by Base.metadata.create_all at startup — no migration needed.
    """
    __tablename__ = "lead_clicks"

    id: Mapped[int] = mapped_column(primary_key=True, index=True)
    email: Mapped[str] = mapped_column(String(320), nullable=False, index=True)
    expert_username: Mapped[str] = mapped_column(String(100), nullable=False, index=True)
    search_query: Mapped[str] = mapped_column(Text, nullable=True)
    created_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, default=datetime.datetime.utcnow, nullable=False
    )
```

No Alembic migration needed — `Base.metadata.create_all()` in app/main.py lifespan creates new tables automatically.

**2. Add public POST /api/lead-clicks endpoint to app/routers/admin.py** (or create a small dedicated router — follow the existing pattern for events.py):

Add a Pydantic request model:
```python
class LeadClickRequest(BaseModel):
    email: str = Field(..., min_length=1, max_length=320)
    expert_username: str = Field(..., min_length=1, max_length=100)
    search_query: str = Field(default="", max_length=2000)
```

Add the endpoint on the `auth_router` (no admin auth required, same pattern as events.py — public fire-and-forget):
```python
@auth_router.post("/lead-clicks", status_code=202)
def record_lead_click(body: LeadClickRequest, db: Session = Depends(get_db)):
    record = LeadClick(
        email=body.email,
        expert_username=body.expert_username,
        search_query=body.search_query,
    )
    db.add(record)
    db.commit()
    return {"status": "accepted"}
```

NOTE: Use `auth_router` (which has no admin auth dependency) so this is a PUBLIC endpoint, prefixed with `/api/admin` in main.py. Actually, check how auth_router is mounted — if it's mounted under `/api/admin`, then the path would be `/api/admin/lead-clicks`. If the events router is mounted at `/api/events`, consider adding to a similar public router. The key requirement: NO admin auth needed on this endpoint. Check main.py router registration to determine the correct router to use. If auth_router is mounted at `/api/admin` prefix, create the endpoint there. The frontend will POST to whatever the mounted path is.

**3. Add admin GET endpoints on the `router` (admin-auth required)**:

GET /lead-clicks (grouped by email, with batch expert name lookup):
```python
@router.get("/lead-clicks")
def get_lead_clicks(db: Session = Depends(get_db)):
    rows = db.scalars(
        select(LeadClick).order_by(LeadClick.created_at.desc())
    ).all()

    # Batch lookup expert names to avoid N+1
    all_usernames = {row.expert_username for row in rows}
    experts_map = {
        e.username: f"{e.first_name} {e.last_name}"
        for e in db.scalars(select(Expert).where(Expert.username.in_(all_usernames))).all()
    } if all_usernames else {}

    leads: dict = {}
    for row in rows:
        expert_name = experts_map.get(row.expert_username, row.expert_username)
        if row.email not in leads:
            leads[row.email] = []
        leads[row.email].append({
            "expert_username": row.expert_username,
            "expert_name": expert_name,
            "search_query": row.search_query,
            "created_at": row.created_at.isoformat(),
        })

    return {"leads": [{"email": email, "clicks": clicks} for email, clicks in leads.items()]}
```

GET /lead-clicks/by-expert/{username}:
```python
@router.get("/lead-clicks/by-expert/{username}")
def get_lead_clicks_by_expert(username: str, db: Session = Depends(get_db)):
    rows = db.scalars(
        select(LeadClick)
        .where(LeadClick.expert_username == username)
        .order_by(LeadClick.created_at.desc())
    ).all()
    return {
        "expert_username": username,
        "clicks": [
            {"email": r.email, "search_query": r.search_query, "created_at": r.created_at.isoformat()}
            for r in rows
        ],
    }
```

**4. Update the existing `reset_data` endpoint** (around line 1910 in admin.py) to include `LeadClick` in the wipe list. Add `LeadClick` to the `for model in [...]` loop alongside the existing models (Feedback, Conversation, EmailLead, NewsletterSubscriber, UserEvent). Import `LeadClick` at the top of admin.py from `app.models`.

**IMPORTANT:** Make sure `LeadClick` is imported in admin.py at the top with the other model imports.
  </action>
  <verify>
    <automated>cd /Users/sebastianhamers/Documents/TCS && python -c "from app.models import LeadClick; print('LeadClick model OK:', LeadClick.__tablename__)"</automated>
    <manual>Check that admin.py has all 4 new elements: LeadClickRequest, record_lead_click, get_lead_clicks, get_lead_clicks_by_expert, and LeadClick in reset_data wipe list</manual>
  </verify>
  <done>LeadClick model exists in models.py with email+expert_username+search_query+created_at fields. Public POST endpoint accepts lead clicks without auth. Admin GET endpoints return clicks grouped by email (with expert full names) and by expert. Reset-data endpoint includes lead_clicks table in wipe.</done>
</task>

<task type="auto">
  <name>Task 2: Add frontend lead-click capture in ExpertCard + TypeScript types</name>
  <files>frontend/src/components/marketplace/ExpertCard.tsx, frontend/src/admin/types.ts</files>
  <action>
**1. Extend ExpertCard.tsx click handler** to also fire a lead-click POST when the user is email-identified:

In the `handleCardClick` function (or wherever the card click event fires `trackEvent('card_click', ...)`), add AFTER the existing trackEvent call:

```typescript
// Read email from nltrStore (static getState, NOT the hook — same pattern as useExplorerStore.getState())
import { useNltrStore } from '../../store/nltrStore'  // or correct relative path

// Inside handleCardClick:
const nltrEmail = useNltrStore.getState().email

if (nltrEmail) {
  void fetch(`${API_BASE}/api/lead-clicks`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    keepalive: true,
    body: JSON.stringify({
      email: nltrEmail,
      expert_username: expert.username,
      search_query: storeState.query,
    }),
  })
}
```

CRITICAL: The fetch URL must match the actual mounted path of the lead-clicks endpoint. Check main.py to see how `auth_router` is mounted — if under `/api/admin`, then use `${API_BASE}/api/admin/lead-clicks`. If a different mount point, adjust accordingly.

CRITICAL: Use `useNltrStore.getState()` (NOT the hook `useNltrStore()`). The `.getState()` pattern is already used in this file for `useExplorerStore.getState()` — follow the exact same approach.

CRITICAL: The `API_BASE` constant — find how the existing `trackEvent` or other fetch calls in this file determine the API base URL, and use the same approach.

**2. Add TypeScript types to frontend/src/admin/types.ts**:

```typescript
// Lead click tracking types
export interface LeadClickEntry {
  expert_username: string
  expert_name: string
  search_query: string
  created_at: string
}

export interface LeadClicksByEmail {
  email: string
  clicks: LeadClickEntry[]
}

export interface LeadClicksResponse {
  leads: LeadClicksByEmail[]
}

export interface LeadClicksByExpertResponse {
  expert_username: string
  clicks: {
    email: string
    search_query: string
    created_at: string
  }[]
}
```
  </action>
  <verify>
    <automated>cd /Users/sebastianhamers/Documents/TCS/frontend && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>Verify ExpertCard.tsx has the nltrStore import and the conditional lead-click fetch inside the click handler</manual>
  </verify>
  <done>ExpertCard fires POST /api/lead-clicks with email+expert_username+search_query when nltrStore.email is set. No lead-click fires for anonymous users. TypeScript types for LeadClick responses are defined in admin/types.ts.</done>
</task>

</tasks>

<verification>
1. `python -c "from app.models import LeadClick; print(LeadClick.__tablename__)"` prints "lead_clicks"
2. `cd frontend && npx tsc --noEmit` passes with no errors
3. ExpertCard.tsx contains `useNltrStore.getState().email` and a conditional fetch to `/api/lead-clicks`
4. admin.py contains `record_lead_click`, `get_lead_clicks`, `get_lead_clicks_by_expert` functions
5. admin.py reset_data function includes `LeadClick` in the wipe list
6. admin/types.ts contains `LeadClickEntry`, `LeadClicksResponse`, `LeadClicksByExpertResponse`
</verification>

<success_criteria>
- LeadClick model auto-creates on startup (verified by import test)
- Public endpoint accepts lead clicks without auth
- Admin endpoints return structured click data grouped by email and by expert
- Frontend captures clicks only for email-identified users
- TypeScript compiles without errors
- Reset endpoint includes lead_clicks in wipe
</success_criteria>

<output>
After completion, create `.planning/milestones/v4.0-phases/50.1-lead-click-tracking-data-reset-search-visibility/50.1-01-SUMMARY.md`
</output>
