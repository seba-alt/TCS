---
phase: 45-security-and-infrastructure-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - requirements.txt
  - app/models.py
  - app/limiter.py
  - app/routers/admin.py
  - app/main.py
  - frontend/src/admin/LoginPage.tsx
  - frontend/src/admin/RequireAuth.tsx
  - frontend/src/admin/hooks/useAdminData.ts
autonomous: true
requirements: [SEC-01, SEC-02]

must_haves:
  truths:
    - "Admin can log in with username and password; server returns a JWT token"
    - "Old single-key auth (X-Admin-Key header) no longer grants access to any admin endpoint"
    - "More than 5 requests to /api/admin/auth within one minute from the same IP return 429"
    - "Frontend stores JWT in sessionStorage and sends it as Authorization: Bearer header on all admin API calls"
    - "Invalid or expired JWT returns 401 on protected admin endpoints"
    - "Generic 'Invalid credentials' message shown for wrong username OR wrong password"
  artifacts:
    - path: "app/models.py"
      provides: "AdminUser SQLAlchemy model"
      contains: "class AdminUser"
    - path: "app/limiter.py"
      provides: "Shared slowapi limiter singleton"
      contains: "Limiter"
    - path: "app/routers/admin.py"
      provides: "JWT-based auth endpoint and _require_admin dependency"
      contains: "jwt.decode"
    - path: "frontend/src/admin/LoginPage.tsx"
      provides: "Username + password login form"
      contains: "username"
    - path: "frontend/src/admin/hooks/useAdminData.ts"
      provides: "Authorization: Bearer header on all admin fetches"
      contains: "Authorization"
  key_links:
    - from: "frontend/src/admin/LoginPage.tsx"
      to: "/api/admin/auth"
      via: "POST {username, password} -> receives {token}"
      pattern: "JSON\\.stringify.*username.*password"
    - from: "frontend/src/admin/hooks/useAdminData.ts"
      to: "all /api/admin/* endpoints"
      via: "Authorization: Bearer <jwt> header"
      pattern: "Authorization.*Bearer"
    - from: "app/routers/admin.py"
      to: "app/models.py AdminUser"
      via: "select(AdminUser) for credential verification"
      pattern: "select.*AdminUser"
    - from: "app/main.py"
      to: "app/limiter.py"
      via: "registers limiter on app.state and exception handler"
      pattern: "app\\.state\\.limiter"
---

<objective>
Upgrade admin authentication from single-key to bcrypt+JWT username/password and add rate limiting on the login endpoint.

Purpose: Replace the insecure single shared key with proper credential-based auth (bcrypt hashed password + signed JWT) and protect against brute-force attacks before public launch.
Output: Backend auth endpoints using PyJWT + pwdlib[bcrypt], slowapi rate limiting, and frontend login form with JWT-based session management.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-security-and-infrastructure-hardening/45-CONTEXT.md
@.planning/phases/45-security-and-infrastructure-hardening/45-RESEARCH.md
@app/routers/admin.py
@app/models.py
@app/database.py
@app/main.py
@frontend/src/admin/LoginPage.tsx
@frontend/src/admin/RequireAuth.tsx
@frontend/src/admin/hooks/useAdminData.ts
@requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend auth upgrade — AdminUser model, JWT auth endpoint, rate limiting</name>
  <files>
    requirements.txt
    app/models.py
    app/limiter.py
    app/routers/admin.py
    app/main.py
  </files>
  <action>
**1. Add dependencies to requirements.txt:**
Append these three lines after the existing packages (before the Dev section):
```
pyjwt==2.10.*
pwdlib[bcrypt]==0.3.*
slowapi==0.1.*
```

**2. Add AdminUser model to app/models.py:**
Add a new `AdminUser` class after the existing models:
```python
class AdminUser(Base):
    __tablename__ = "admin_users"
    id: Mapped[int] = mapped_column(primary_key=True)
    username: Mapped[str] = mapped_column(String(100), unique=True, nullable=False)
    hashed_password: Mapped[str] = mapped_column(String(200), nullable=False)
    created_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, default=datetime.datetime.utcnow, nullable=False
    )
```

**3. Create app/limiter.py** (new file — shared module to avoid circular imports between main.py and admin.py):
```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)
```

**4. Rewrite auth section in app/routers/admin.py:**
- Remove `_api_key_header = APIKeyHeader(name="X-Admin-Key", auto_error=False)` and the old `_require_admin` function.
- Add imports: `import jwt`, `from jwt.exceptions import InvalidTokenError`, `from pwdlib import PasswordHash`, `from pwdlib.hashers.bcrypt import BcryptHasher`, `from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials`, `from app.limiter import limiter`, `from app.models import AdminUser` (add to existing import).
- Define module-level constants:
  ```python
  SECRET_KEY = os.getenv("JWT_SECRET", "")
  ALGORITHM = "HS256"
  JWT_EXPIRE_HOURS = 24
  _pwd = PasswordHash([BcryptHasher()])
  _bearer = HTTPBearer(auto_error=False)
  ```
- Replace `_require_admin` with JWT verification:
  ```python
  def _require_admin(credentials: Optional[HTTPAuthorizationCredentials] = Security(_bearer)) -> str:
      if not credentials:
          raise HTTPException(status_code=401, detail="Missing Authorization header")
      if not SECRET_KEY:
          raise HTTPException(status_code=500, detail="JWT_SECRET not configured")
      try:
          payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
          username: str = payload.get("sub")
          if not username:
              raise InvalidTokenError
          return username
      except InvalidTokenError:
          raise HTTPException(status_code=401, detail="Invalid or expired token")
  ```
- Replace `AuthBody` model: change `key: str` to `username: str` and `password: str`.
- Replace the `authenticate` endpoint:
  ```python
  @auth_router.post("/auth")
  @limiter.limit("5/minute")
  def authenticate(body: AuthBody, request: Request):
      if not SECRET_KEY:
          raise HTTPException(status_code=500, detail="JWT_SECRET not configured")
      with SessionLocal() as db:
          user = db.scalar(select(AdminUser).where(AdminUser.username == body.username))
      if not user or not _pwd.verify(body.password, user.hashed_password):
          raise HTTPException(status_code=401, detail="Invalid credentials")
      from datetime import timezone, timedelta
      expire = datetime.now(timezone.utc) + timedelta(hours=JWT_EXPIRE_HOURS)
      token = jwt.encode({"sub": user.username, "exp": expire}, SECRET_KEY, algorithm=ALGORITHM)
      return {"token": token}
  ```
  Note: `request: Request` parameter is REQUIRED for slowapi to work. The `@limiter.limit` decorator MUST be below `@auth_router.post`.
- Remove the `from fastapi.security import APIKeyHeader` import (no longer needed). Keep `Security` import.

**5. Update app/main.py:**
- Add import: `from slowapi.errors import RateLimitExceeded`, `from slowapi import _rate_limit_exceeded_handler`, `from app.limiter import limiter`.
- After `app = FastAPI(...)` line, add:
  ```python
  app.state.limiter = limiter
  app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)
  ```
- Update CORS `allow_headers` from `["Content-Type", "X-Admin-Key"]` to `["Content-Type", "Authorization"]`.
- In the lifespan function, after `Base.metadata.create_all(bind=engine)` and before `yield`, add admin user seeding:
  ```python
  # Seed admin user from env vars on first boot
  _admin_user = os.getenv("ADMIN_USERNAME", "")
  _admin_pass = os.getenv("ADMIN_PASSWORD", "")
  if _admin_user and _admin_pass:
      from app.models import AdminUser
      from pwdlib import PasswordHash
      from pwdlib.hashers.bcrypt import BcryptHasher
      _pwd = PasswordHash([BcryptHasher()])
      with SessionLocal() as _db:
          existing = _db.scalar(select(func.count()).select_from(AdminUser))
          if existing == 0:
              _db.add(AdminUser(username=_admin_user, hashed_password=_pwd.hash(_admin_pass)))
              _db.commit()
              log.info("startup: admin user seeded", username=_admin_user)
  elif not os.getenv("JWT_SECRET"):
      log.warning("startup: ADMIN_USERNAME/ADMIN_PASSWORD not set — admin login disabled")
  ```
- Add a startup assertion for JWT_SECRET:
  ```python
  if not os.getenv("JWT_SECRET") and os.getenv("RAILWAY_ENVIRONMENT"):
      log.error("startup: JWT_SECRET must be set in production")
  ```

**Important:** Do NOT use `PasswordHash.recommended()` — that defaults to Argon2. Explicitly use `PasswordHash([BcryptHasher()])` per SEC-01 requirement.
  </action>
  <verify>
    <automated>cd /Users/sebastianhamers/Documents/TCS && pip install pyjwt "pwdlib[bcrypt]" slowapi -q && python -c "from app.models import AdminUser; from app.limiter import limiter; from app.routers.admin import _require_admin, authenticate; print('imports OK')"</automated>
    <manual>Verify that admin.py no longer contains any reference to X-Admin-Key or ADMIN_SECRET</manual>
  </verify>
  <done>
    - AdminUser model exists in models.py with username + hashed_password fields
    - app/limiter.py exports a shared Limiter singleton
    - Auth endpoint accepts {username, password}, verifies against bcrypt hash, returns {token: jwt}
    - _require_admin verifies JWT from Authorization: Bearer header
    - Rate limiter (5/minute) applied to auth endpoint via slowapi
    - CORS updated to allow Authorization header instead of X-Admin-Key
    - Admin user seeded from ADMIN_USERNAME + ADMIN_PASSWORD env vars on first boot
    - No references to X-Admin-Key or ADMIN_SECRET remain in backend code
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend auth migration — username/password form and JWT Bearer headers</name>
  <files>
    frontend/src/admin/LoginPage.tsx
    frontend/src/admin/RequireAuth.tsx
    frontend/src/admin/hooks/useAdminData.ts
  </files>
  <action>
**1. Update LoginPage.tsx:**
- Replace single `key` state with `username` and `password` states.
- Update `handleSubmit` to POST `{ username, password }` instead of `{ key }`.
- On success, store the returned `token` in sessionStorage as `admin_token` (not `admin_key`).
- Remove `admin_key` from sessionStorage on login (clean up old key if present): `sessionStorage.removeItem('admin_key')`.
- Update the `useEffect` redirect check to look for `admin_token` instead of `admin_key`.
- Replace the single password input with two fields:
  - Username: `type="text"`, placeholder "Username", `autoComplete="username"`
  - Password: `type="password"`, placeholder "Password", `autoComplete="current-password"`
- Update error message to "Invalid credentials" (generic, per CONTEXT.md decision).
- Update page subtitle from "Enter your admin key to continue" to "Sign in to continue".
- Update the label from "Admin Key" to separate "Username" and "Password" labels.
- Keep the existing design/styling — just swap the input fields.

**2. Update RequireAuth.tsx:**
- Change `sessionStorage.getItem('admin_key')` to `sessionStorage.getItem('admin_token')`.

**3. Update useAdminData.ts:**
- Change `getAdminKey` function to `getAdminToken`: return `sessionStorage.getItem('admin_token') ?? ''`.
- In `adminFetch`: change header from `{ 'X-Admin-Key': getAdminKey() }` to `{ 'Authorization': \`Bearer \${getAdminToken()}\` }`.
- In `adminPost`: same header change — replace `'X-Admin-Key': getAdminKey()` with `'Authorization': \`Bearer \${getAdminToken()}\``.
- In `adminPostFormData`: same header change.
- In `useEmbeddingMap` poll function: change the direct `fetch` call's header from `{ 'X-Admin-Key': getAdminKey() }` to `{ 'Authorization': \`Bearer \${getAdminToken()}\` }`.
- Handle 401 responses globally: in `adminFetch`, if `res.status === 401`, clear sessionStorage (`sessionStorage.removeItem('admin_token')`) and redirect to login: `window.location.href = '/admin/login'`. This handles expired JWT gracefully.

**Important:** The session lasts until browser tab closes — `sessionStorage` already handles this (cleared on tab close). The 24h JWT expiry is a server-side safety net. No "remember me" or persistent login needed.
  </action>
  <verify>
    <automated>cd /Users/sebastianhamers/Documents/TCS/frontend && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Verify LoginPage shows username + password fields, useAdminData sends Authorization: Bearer header</manual>
  </verify>
  <done>
    - Login page shows username + password fields (not single key field)
    - Successful login stores JWT as `admin_token` in sessionStorage
    - All admin API calls use `Authorization: Bearer <token>` header
    - RequireAuth checks for `admin_token` in sessionStorage
    - 401 responses redirect to login page (expired token handling)
    - No references to `admin_key` or `X-Admin-Key` remain in frontend code
  </done>
</task>

</tasks>

<verification>
1. Backend: `python -c "from app.routers.admin import authenticate, _require_admin; print('OK')"` — imports succeed
2. Backend: Grep for `X-Admin-Key` in `app/` — zero matches
3. Backend: Grep for `ADMIN_SECRET` in `app/` — zero matches (except possibly comments)
4. Frontend: `npx tsc --noEmit` — no type errors
5. Frontend: Grep for `admin_key` in `frontend/src/admin/` — zero matches
6. Frontend: Grep for `X-Admin-Key` in `frontend/src/admin/` — zero matches
</verification>

<success_criteria>
- Admin login endpoint accepts {username, password} and returns {token: jwt_string}
- All admin endpoints verify JWT from Authorization: Bearer header
- Rate limiting (5/minute) active on auth endpoint
- Frontend login form has username + password fields
- Frontend sends Authorization: Bearer header on all admin requests
- No references to old auth pattern (X-Admin-Key, ADMIN_SECRET, admin_key) in active code
</success_criteria>

<output>
After completion, create `.planning/phases/45-security-and-infrastructure-hardening/45-01-SUMMARY.md`
</output>
