---
phase: 12-steering-panel-frontend
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/admin/types.ts
  - frontend/src/admin/hooks/useAdminData.ts
autonomous: true
requirements: [PANEL-01, PANEL-02, PANEL-03, PANEL-04]

must_haves:
  truths:
    - "AdminSetting and AdminSettingsResponse types exist in types.ts and match the GET /api/admin/settings response shape"
    - "useAdminSettings hook fetches all 5 settings on mount and exposes refetch"
    - "adminPost is usable from useAdminData.ts for writing individual settings via POST /api/admin/settings"
  artifacts:
    - path: "frontend/src/admin/types.ts"
      provides: "AdminSetting and AdminSettingsResponse interfaces"
      contains: "AdminSetting"
    - path: "frontend/src/admin/hooks/useAdminData.ts"
      provides: "useAdminSettings hook"
      contains: "useAdminSettings"
  key_links:
    - from: "frontend/src/admin/hooks/useAdminData.ts"
      to: "/api/admin/settings"
      via: "adminFetch in useAdminSettings"
      pattern: "adminFetch.*settings"
    - from: "frontend/src/admin/pages/IntelligenceDashboardPage.tsx"
      to: "useAdminSettings"
      via: "import from hooks/useAdminData"
      pattern: "useAdminSettings"
---

<objective>
Add TypeScript types and a data hook for the settings API, giving the steering panel component a typed interface to read and write all 5 intelligence settings.

Purpose: Plan 02 (IntelligenceDashboardPage redesign) depends on these types and hook. Separating them into Plan 01 keeps each plan focused and within context budget.
Output: AdminSetting + AdminSettingsResponse interfaces in types.ts; useAdminSettings hook in useAdminData.ts.
</objective>

<execution_context>
@/Users/sebastianhamers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastianhamers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-steering-panel-frontend/12-CONTEXT.md
@frontend/src/admin/types.ts
@frontend/src/admin/hooks/useAdminData.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AdminSetting types to types.ts</name>
  <files>frontend/src/admin/types.ts</files>
  <action>
Append these interfaces at the end of frontend/src/admin/types.ts:

```typescript
export interface AdminSetting {
  key: string
  value: boolean | number         // native typed (bool for flags, float/int for thresholds)
  raw: string                     // original string value from DB or env var
  source: 'db' | 'env' | 'default'  // override hierarchy indicator from backend
  type: 'bool' | 'float' | 'int'
  description: string
  min?: number
  max?: number
}

export interface AdminSettingsResponse {
  settings: AdminSetting[]
}
```

The AdminSetting shape mirrors the GET /api/admin/settings response exactly as implemented in Phase 11 (11-02-SUMMARY.md): value is native-typed (bool/float/int), source indicates whether the active value came from DB override, Railway env var fallback, or hardcoded default.
  </action>
  <verify>Run `npm run build` from frontend/ — TypeScript must compile with zero errors.</verify>
  <done>AdminSetting and AdminSettingsResponse interfaces exist in types.ts, build passes.</done>
</task>

<task type="auto">
  <name>Task 2: Add useAdminSettings hook to useAdminData.ts</name>
  <files>frontend/src/admin/hooks/useAdminData.ts</files>
  <action>
Add the following import at the top of useAdminData.ts (extend the existing import type block):
- Add AdminSettingsResponse to the existing `import type { ... } from '../types'` statement

Then append this hook at the end of useAdminData.ts, following the same loading/error/data pattern used by useAdminStats and useAdminGaps:

```typescript
export function useAdminSettings() {
  const [data, setData] = useState<AdminSettingsResponse | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const fetchData = useCallback(() => {
    setLoading(true)
    adminFetch<AdminSettingsResponse>('/settings')
      .then(setData)
      .catch((e: Error) => setError(e.message))
      .finally(() => setLoading(false))
  }, [])

  useEffect(() => { fetchData() }, [fetchData])

  return { data, loading, error, refetch: fetchData }
}
```

Note: adminPost is already exported from useAdminData.ts — Plan 02 will use it directly for writes. No additional export needed here.
  </action>
  <verify>Run `npm run build` from frontend/ — zero TypeScript errors. Confirm AdminSettingsResponse appears in the import list at the top of useAdminData.ts.</verify>
  <done>useAdminSettings hook exported from useAdminData.ts, imports AdminSettingsResponse, fetches on mount, exposes refetch. Build passes.</done>
</task>

</tasks>

<verification>
From frontend/ directory:
- `npm run build` exits 0
- `grep -n "AdminSetting" frontend/src/admin/types.ts` shows both AdminSetting and AdminSettingsResponse interfaces
- `grep -n "useAdminSettings" frontend/src/admin/hooks/useAdminData.ts` shows the exported hook
</verification>

<success_criteria>
- AdminSetting interface has: key, value (boolean|number), raw (string), source ('db'|'env'|'default'), type ('bool'|'float'|'int'), description, optional min/max
- AdminSettingsResponse interface has: settings: AdminSetting[]
- useAdminSettings hook exists in useAdminData.ts, fetches GET /api/admin/settings on mount, returns { data, loading, error, refetch }
- TypeScript build passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-steering-panel-frontend/12-01-SUMMARY.md`
</output>
